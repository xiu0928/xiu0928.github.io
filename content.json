{"meta":{"title":"我的快乐","subtitle":"欢迎光临 我的快乐","description":null,"author":"李秀远","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2019-10-15T06:56:52.162Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2019-10-15T06:57:25.457Z","comments":true,"path":"contact/index.html","permalink":"http://yoursite.com/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-14T05:10:38.000Z","updated":"2019-10-15T06:55:43.792Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-10-15T06:57:48.160Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-14T05:11:36.000Z","updated":"2019-10-15T06:56:10.881Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL 函数","slug":"SQL函数","date":"2019-10-17T09:36:12.000Z","updated":"2019-10-17T10:59:01.561Z","comments":true,"path":"2019/10/17/SQL函数/","link":"","permalink":"http://yoursite.com/2019/10/17/SQL函数/","excerpt":"","text":"avg（）函数定义和用法AVG 函数返回数值列的平均值。NULL 值不包括在计算中。 SQL AVG() 语法select avg(字段名)as 新字段名 from 表名; 实例我们拥有下面这个stuinfo表： id date name age ach tuition sex 1 2019-10-17 17:44:45 亚索 18 84 10600 男 2 2018-10-17 17:45:42 寒冰 16 95 10600 女 3 2019-08-01 17:45:34 布隆 10 84 10000 男 4 2019-01-17 17:46:42 劫 23 99 500 男 5 2019-10-13 17:46:52 小鱼儿 45 84 6000 女 例子 1现在，我们希望计算 age 字段的平均值。 我们使用如下 SQL 语句：select avg(age)as avgAge from stuinfo;结果集类似这样： avgAge 22.4000 例子 2现在，我们希望找到 age 值高于 age 平均值的客户。我们使用如下 SQL 语句：select name from stuinfo where age&gt;(select avg(age) from stuinfo); name 劫 小鱼儿 count()语句COUNT() 函数返回匹配指定条件的行数。 COUNT(column_name)函数返回指定列的值的数目（NULL 不计入）：语法SELECT COUNT(column_name) FROM table_name COUNT(*)函数返回表中的记录数：SELECT COUNT(*) FROM table_name COUNT(DISTINCT column_name)函数返回指定列的不同值的数目：SELECT COUNT(DISTINCT column_name) FROM table_name 实例我们拥有下面这个stuinfo表： id date name age ach tuition sex 1 2019-10-17 17:44:45 亚索 18 84 10600 男 2 2018-10-17 17:45:42 寒冰 16 95 10600 女 3 2019-08-01 17:45:34 布隆 10 84 10000 男 4 2019-01-17 17:46:42 劫 23 99 500 男 5 2019-10-13 17:46:52 小鱼儿 45 84 6000 女 现在，我们希望计算学生 tuition 的10600学费总数。我们使用如下 SQL 语句：select count(tuition) as countTuition from stuinfo where tuition = 10600;以上 SQL 语句的结果是 2，因为学生 tuition 共有 2 人： countTuition 2 SQL COUNT(*) 实例如果我们省略 WHERE 子句，比如这样：select count(*) as count from stuinfo;结果集类似这样： count 5 这是表中的总行数。 SQL COUNT(DISTINCT column_name) 实例现在，我们希望计算 “stuinfo” 表中不同成绩的数目。我们使用如下 SQL 语句：select count(distinct ach) as numAch from stuinfo;结果集类似这样： numAch 3 max()函数MAX 函数返回一列中的最大值。NULL 值不包括在计算中。SQL MAX() 语法SELECT MAX(column_name) FROM table_name min()函数MIN 函数返回一列中的最小值。NULL 值不包括在计算中。SQL MIN() 语法SELECT MIN(column_name) FROM table_name注释：MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。 sum()函数SUM 函数返回数值列的总数（总额）。SQL SUM() 语法SELECT SUM(column_name) FROM table_name first()函数FIRST() 函数返回指定的字段中第一个记录的值。 提示：可使用 ORDER BY 语句对记录进行排序。SQL FIRST() 语法SELECT FIRST(column_name) FROM table_name list()函数LAST() 函数返回指定的字段中最后一个记录的值。 提示：可使用 ORDER BY 语句对记录进行排序。SQL LAST() 语法SELECT LAST(column_name) FROM table_name Group By函数GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。SQL GROUP BY 语法 SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name 实例我们拥有下面这个 “stuinfo” 表： id date name age ach tuition sex 1 2019-10-17 17:44:45 亚索 18 84 10600 男 2 2018-10-17 17:45:42 寒冰 16 95 10600 女 3 2019-08-01 17:45:34 布隆 10 84 10000 男 4 2019-01-17 17:46:42 劫 23 99 500 男 5 2019-10-13 17:46:52 小鱼儿 45 84 6000 女 现在我们希望查找男生和女生的总分数并想要使用 GROUP BY 进行组合。我们使用下列 SQL 语句：select sex,sum(ach) from stuinfo group by sex;结果： sex sum(ach) 女 179 男 267 Having();在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。SQL HAVING 语法 SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name HAVING aggregate_function(column_name) operator value","categories":[{"name":"SQL函数","slug":"SQL函数","permalink":"http://yoursite.com/categories/SQL函数/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"Hexo安装教程","slug":"Hexo","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-17T09:37:39.044Z","comments":true,"path":"2019/10/16/Hexo/","link":"","permalink":"http://yoursite.com/2019/10/16/Hexo/","excerpt":"","text":"安装hexo基础框架npm install hexo-cli -g 更新内容我是用windows系统，打开cmd然后进入到你的博客文件目录，输入以下命令 hexo clean hexo g hexo d 网易云音乐外链https://music.163.com/song/media/outer/url?id=484365611.mp3 清空git缓存git rm -r --cached . git gc 更换仓库：git remote -v git remote set-url origin 新仓库 git remote set-url origin https://github.com/xiu0928/love.git 查看当前用户名和邮箱git config user.name git config user.email 修改git config --global user.name \"xiu0928\" git config --global user.email \"2011447576@qq.com\" 上传项目git init git add . git commit -m \"first commit\" git remote add origin https://自己的仓库url地址（上面有说到） 将本地的仓库关联到github上， git push -u origin master 更新到GitHub上hexo clean hexo generate hexo deploy 更新到GitHub上git clone https://github.com/xiu0928/xiu0928.github.io .deploy/xiu0928.github.io hexo generate //生成静态文件 cp -R public/* .deploy/xiu0928.github.io //复制文件 cd .deploy/xiu0928.github.io //切换目录 git add . //将需要提交的代码添加到暂存区 git commit -m \"update\" //将暂存区内容提交给本地版本库 git push //推送给远程服务器","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"-Hexo -技术 -Git","slug":"Hexo-技术-Git","permalink":"http://yoursite.com/tags/Hexo-技术-Git/"}]},{"title":"Java总结","slug":"Java总结","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-17T09:37:33.419Z","comments":true,"path":"2019/10/16/Java总结/","link":"","permalink":"http://yoursite.com/2019/10/16/Java总结/","excerpt":"","text":"Java开篇javaSE（标准版） javaEE（企业版） javaME（微型版） JDK（java开发工具包）JRE（java运行环境）IDE（集成开发环境） Java SE（Java Platform，Standard Edition）。Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。 J2SE就是做那种桌面安装程序样的，像QQ，WORD那种应用程序。Java EE（Java Platform，Enterprise Edition）。这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。 J2EE 就是做基于Internet的应用程序，像选课系统，企业网站，银行系统之类的。Java ME（Java Platform，Micro Edition）。这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。 J2ME就是做嵌入式系统开发的，像手机游戏之类的，像现在流行的Android操作系统。JDK（Java Development Kit）。JRE（Java Runtime Environment）IDE（Ind Depvelopment Environment） ##一、面向对象 类、对象、变量（1）所有的Java程序都已类class为组织单元；类由属性和方法两部分组成（2）先创建对象，再使用对象（3）成员变量：类中定义，自动定义初始值局部变量：类方法中定义（两变量同名，局部变量有更高的优先级） 构造方法构造方法是定义在java类中的一个用来初始化对象的方法，与类同名且没有返回值。 public 构造方法名（）{ } 其中构造方法名与类同名；当没有指定的构造方法时，系统会自动添加无参构造方法 Static使用Static修饰的成员属于整个类，被类的所有对象共享。可通过使用类名直接访问静态成员，也可通过对象名Static可以修饰变量、方法和代码块 （1）Static使用之静态方法public class Helloworld { public static void print() { System.out.println(“***”); } public static void main(String[] args) { Helloworld.print(); Helloworld demo = new Helloworld; demo.print(); } } 注意：静态方法中可以直接调用同类的静态成员，但不可以直接调用非静态成员；普通成员方法中可以直接访问同类的非静态变量和静态变量；静态方法中不能直接调用非静态成员方法 （2）Static使用之静态初始化块静态初始化块在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通成员 public class Helloworld { int num1; int num2; static int num3; public Helloworld() { num1 = 91; System.out.println(\"构造方法为num1赋值\"); num2 = 74; System.out.println(\"初始化块为num2赋值\"); num3 = 83; System.out.println(\"静态初始化块为num3赋值\"); } public static void main(String[] args) { Helloworld hello = new Helloworld(); System.out.println(hello.num1); System.out.println(hello.num2); System.out.println(num3); Helloworld hello2 = new Helloworld(); } } 运行结果：静态初始化块为num3赋值初始化块为num2赋值构造方法为num1赋值 91 74 83 初始化块为num2赋值构造方法为num1赋值 二、java面向对象的特性封装性：将类的某些信息隐藏在内部，通过类的方法来实现操作访问步骤：1 修改属性可见性；2 创建getter\\setter方法；3在方法中加入属性控制语句 (1)静态内部类:public class SOuter { private int a = 99; static int b = 1; public static class SInner { int b = 2; public void test() { System.out.println(\"访问外部类b\" + SOuter.b); System.out.println(\"访问内部类b\" + b); } } public static void main(String[] args) { //三行表示 SInner sInner; sInner = new SInner(); sInner.test(); //两行表示 SInner si = new SInner(); si.test(); //一行表示 new SInner().test(); } } (2)成员内部类：访问外部类时使用this指针（3）方法内部类：只能在该方法中使用，且不能使用访问控制符和Static修饰符 2. 继承性（1）一般形式：class 子类 extends 父类（2）方法重写：子类对继承的父类方法不满意可以重写，调用时优先调用子类方法（3）继承的初始化顺序：先初始化父类，再到子类；先执行初始化对象中属性，再执行狗在方法中的初始化（4）父类对象–属性初始化–构造方法–子类对象–属性初始化–构造方法（5）注意：如果子类构造方法中没有显示调用父类的构造方法，默认调用父类无参构造方法，若此父类没用无参的构造方法，则编译出错 多态性引用多态：父类的引用可以指向本类的对象，也可指向子类的对象方法多态：创建本类对象时，调用的方法为本类方法；创建子类对象时，调用的方法为子类的重写的方法或者继承的方法 （1）抽象类用关键字abstract修饰：抽象类只用声明不需要实现；包含抽象方法的类为抽象类；抽象类不能直接创建，可以定义引用变量。 public abstract class Telphone{ public abstract void call(); //抽象方法没有方法体，以分号结束 } （2）接口（一种特殊的类，有全局变量和公共抽象方法组成）[修饰符] class 类名 extends 父类implemrnts 接口1,2…… {类体部分 } 注：接口经常与匿名内部类配合使用 public interface Iplay{ public void phone(); } public class People implements Iplay{ public static void main(String[] args){ People test=new People(); test.phone(); } public void phone(){ System.out.println(“手机可以玩游戏”); } } 1.String、StringBuilder、StringBuffer的区别是什么，String为什么是不可变的？不可变性String类的底层源码中，通过final关键字修饰字符串数组，private final char value[]，所以是不可变的。StringBuffer和StringBuilder类是集成自 AbstractStringBuilder 类， AbstractStringBuilder 类中的变量没有用final关键字修饰，所以是可变的。 线程安全性String是不可变的，是常量，所以是线程安全的。StringBuilder和StringBuffer都继承自AbstractStringBuilder 类，StringBuffer对方法加了同步锁，所以是线程安全的，而StringBuilder没有加同步锁，所以是线程不安全的。 性能对String类型进行改变是都会new一个新的string对象，并指向新的对象； StringBuffer直接通过改变自身变量的值，StringBuilder相对能提升性能，但有线程不安全的情况。 2.== 与 equals==用来判断两个对象是否相等，基础数据类型比较的是值是否相等。 没有重写对象的equals方法时，也是用来比较两个对象是否相等，重写equals方法可以比较内容相等，返回true 3.try/catch/finally中finally是否一定执行在以下4种特殊情况下，finally块不会被执行: 在finally语句块中发生了异常。 在前面的代码中用了System.exit()退出程序。 程序所在的线程死亡。 关闭CPU。 4.接口和抽象类的区别？1.抽象类中可以实现方法，抽象接口不能实现方法（jdk1.8以后可以实现方法）； 2.接口中的变量默认是final类型，而抽象类不是； 3.类只能继承一个抽象类，而接口可以实现多个； 4.类继承接口需要实现所有方法，抽象类不需要； 5.接口不能用new实例化，可以声明。必须引用一个实现该接口的对象抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。5.Arraylist 与 LinkedList 异同安全性ArrayList与LinkedList都是线程不安全的。 数据结构实现ArryayList是基于Object数组，而LinkedList是基于双向循环链表（JDK1.6之前为循环链表，之后取消了循环） 插入删除的影响ArrayList采用数组存储，插入删除受元素位置的影响； LinkedList采用链表存储，插入删除不收元素位置影响； 访问元素LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,未实现RandomAccess接口的list， 优先选择iterator遍历(foreach遍历底层也是通过iterator实现的)，大size的数据，千万不要使用普通for循环 6.ArrayList 与 Vector 区别Vector中所有方法都是同步的，在多线程操作中，同步操作会耗费时间，而ArrayList是不需要同步的，在不需要考虑线程安全时可以使用。 7.HashMap的底层实现待补充完善 8.HashSet 和 HashMap 区别HashMap实现Map接口，用来存储键值对，调用put方法添加元素，使用Key计算Hashcode，而HashSet实现Set接口，用来存储对象，调用add方法添加对象，使用对象计算hashcode，根据equals方法判断对象相等，执行效率的话，HashMap优与HashSet。 9.ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。ConcurrentHashMap使用的是分段锁，HashTable使用的是同一把锁，因而在多线程并发中效率很低。 10.多线程实现方式1.继承Thread类，2.实现Runnable接口，3.基于线程池实现","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"-java -技术 -总结","slug":"java-技术-总结","permalink":"http://yoursite.com/tags/java-技术-总结/"}]},{"title":"SQL基础","slug":"SQL总结","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-17T09:37:49.197Z","comments":true,"path":"2019/10/16/SQL总结/","link":"","permalink":"http://yoursite.com/2019/10/16/SQL总结/","excerpt":"","text":"SQL 语法数据库表一个数据库通常包含一个或多个表。每个表由一个名字标识（例如“客户”或者“订单”）。表包含带有数据的记录（行） SQL 语句您需要在数据库上执行的大部分工作都由 SQL 语句完成。下面的语句从表中选取 LastName 列的数据：SELECT LastName FROM Persons重要事项：SQL 对大小写不敏感！ SQL DML 和 DDL可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。 查询和更新指令构成了 SQL 的 DML 部分： SELECT - 从数据库表中获取数据 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。SQL 中最重要的 DDL 语句: CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL SELECT 语句SELECT 语句用于从表中选取数据。 结果被存储在一个结果表中（称为结果集）。 SQL SELECT 语法SELECT 列名称 FROM 表名称以及：SELECT * FROM 表名称 SQL SELECT DISTINCT 语句在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。 关键词 DISTINCT 用于返回唯一不同的值。语法：SELECT DISTINCT 列名称 FROM 表名称 SQL WHERE 子句如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。语法:SELECT 列名称 FROM 表名称 WHERE 列 运算符 值下面的运算符可在 WHERE 子句中使用： 操作符 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 != SQL AND &amp; OR 运算符AND 和 OR 运算符用于基于一个以上的条件对记录进行过滤。AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。AND 运算符实例使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人：SELECT * FROM Persons WHERE FirstName=&#39;Thomas&#39; AND LastName=&#39;Carter&#39;OR 运算符实例使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人：SELECT * FROM Persons WHERE firstname=&#39;Thomas&#39; OR lastname=&#39;Carter&#39;结合 AND 和 OR 运算符我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）:SELECT * FROM Persons WHERE (FirstName=&#39;Thomas&#39; OR FirstName=&#39;William&#39;) AND LastName=&#39;Carter&#39; SQL ORDER BY 子句ORDER BY 语句用于对结果集进行排序。ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 实例 1以字母顺序显示公司名称：SELECT Company, OrderNumber FROM Orders ORDER BY Company 实例 2以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber SQL INSERT INTO 语句INSERT INTO 语句用于向表格中插入新的行。语法INSERT INTO 表名称 VALUES (值1, 值2,....)我们也可以指定所要插入数据的列：INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....) 插入新的行“Persons” 表： LastName FirstName Address City Carter Thomas Changan Street Beijing SQL 语句：INSERT INTO Persons VALUES (&#39;Gates&#39;, &#39;Bill&#39;, &#39;Xuanwumen 10&#39;, &#39;Beijing&#39;)结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing 在指定的列中插入数据“Persons” 表： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing SQL 语句：INSERT INTO Persons (LastName, Address) VALUES (&#39;Wilson&#39;, &#39;Champs-Elysees&#39;)结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing Wilson Champs-Elysees Update 语句Update 语句用于修改表中的数据。语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 例子Person: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Champs-Elysees 更新某一行中的一个列我们为 lastname 是 “Wilson” 的人添加 firstname：UPDATE Person SET FirstName = &#39;Fred&#39; WHERE LastName = &#39;Wilson&#39;结果： LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Champs-Elysees 更新某一行中的若干列我们会修改地址（address），并添加城市名称（city）：UPDATE Person SET Address = &#39;Zhongshan 23&#39;, City = &#39;Nanjing&#39; WHERE LastName = &#39;Wilson&#39;结果： LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Zhongshan 23 Nanjing SQL DELETE 语句DELETE 语句用于删除表中的行。语法DELETE FROM 表名称 WHERE 列名称 = 值Person: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Zhongshan 23 Nanjing 删除某行“Fred Wilson” 会被删除：DELETE FROM Person WHERE LastName = &#39;Wilson&#39;结果: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing 删除所有行可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：DELETE FROM table_name或者：DELETE * FROM table_name","categories":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/categories/SQL/"}],"tags":[{"name":"-SQL -技术 -基础","slug":"SQL-技术-基础","permalink":"http://yoursite.com/tags/SQL-技术-基础/"}]},{"title":"奇淫巧技","slug":"奇淫巧技","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-17T09:37:44.417Z","comments":true,"path":"2019/10/16/奇淫巧技/","link":"","permalink":"http://yoursite.com/2019/10/16/奇淫巧技/","excerpt":"","text":"Dos代码雨@echo off color 0a :start set num=0 set \"echos= \" :num set /a a1=%random%%%3 if \"%a1%\" == \"1\" set \"a1= \" if \"%a1%\" == \"2\" set \"a1= \" if \"%a1%\" == \"0\" set /a a1=%random%%%2 set echos=%echos%%a1% set /a num=%num%+1 if \"%num%\" == \"75\" echo %echos%&&goto :start goto :num MySQL查看表的所有列show full columns from [table] JavaScript删除数组var arr = [1,2,3,4]; console.log(arr); arr.length = 0; console.log(arr); 特别简单的取整技巧var num = 5.6664; console.log(~~num);//5","categories":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/categories/技巧/"}],"tags":[{"name":"-Dos -技术 -巧记","slug":"Dos-技术-巧记","permalink":"http://yoursite.com/tags/Dos-技术-巧记/"}]}]}