{"meta":{"title":"我的快乐","subtitle":"欢迎光临 我的快乐","description":null,"author":"李秀远","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2019-10-15T06:56:52.162Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-14T05:10:38.000Z","updated":"2019-10-15T06:55:43.792Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2019-10-15T06:57:25.457Z","comments":true,"path":"contact/index.html","permalink":"http://yoursite.com/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-14T05:11:36.000Z","updated":"2019-10-15T06:56:10.881Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-10-15T06:57:48.160Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"图书管理系统问题汇总","slug":"图书管理系统问题汇总","date":"2019-12-05T08:02:22.000Z","updated":"2019-12-05T08:52:12.734Z","comments":true,"path":"2019/12/05/图书管理系统问题汇总/","link":"","permalink":"http://yoursite.com/2019/12/05/图书管理系统问题汇总/","excerpt":"","text":"1. JSTL标签引入失败解决:将JSTL Jar包导入到项目中 2. 使用JSTL服务器抛异常解决: JSTL Jar中tld目录放到webroot/MATA-INF中 3. 数据库编码问题，网页取数据库前台显示乱码。解决:数据库编码与服务器编码统一 4. 图书借阅与归还问题问题描述:同一本图书借出两次，第一次归还没问题，第二次归还在还书系统找不到该借书的信息，但数据库中该图书已经标识已经借出. 解决:借书系统所操作的数据是用户在前台收藏的图书，当在后台借阅后，当前收藏记录就删除了，而还书系统，所操作的数据也是收藏记录，收藏记录删除导致还书系统取不到借书数据，将还书系统对应的数据改为借书的记录。 5. 图书的重复借阅以及重复归还问题问题描述:在借书系统中，当点击借阅后，在该页面刷新网页就会一直重复借阅，还书也是一样。如果图书管理员操作不当，刷新了当前网页，则图书就会出现重复借阅。 解决:在后端中，用户执行了借书操作，如果该图书借阅成功后，重新定向URL，并删除上一次借书的临时数据，则用户无论怎么执行刷新就只是获取借阅图书的信息而已。还书也是该操作。 6.上传图片到服务器问题描述:上传服务器图片到服务器需要刷新img文件夹才能在页面上显示出来 解决:因为上传的路径为绝对路径，更改为相对路径即可代码：String path = request.getSession().getServletContext().getRealPath(&quot;assets/images/book&quot;); 7.用ajax请求服务器返回json数据出错解决：因为没有正确的下载相应版本的jar包，有的jar包的版本之间是有依赖关系的jar包： commons-beanutils-1.7.0.jar commons-collections-3.2.1.jar commons-lang-2.6.jar commons-logging-1.1.3.jar ezmorph-1.0.6.jar json-lib-2.1-jdk15.jar 8.判断用户是否登录解决:在登录的时候，把用户的账号密码存储到Session里面，然后写一个拦截器，拦截需要登录才能进行请求的服务器。 9.关于页面上登录判断的处理解决:在访问页面的时候用ajax进行请求服务器，如果登录会返回用户的信息，如果没登陆会返回为null。然后ajax拿到服务器返回的json数据。进行判断如果有数据则显示登录用户的名字，如果没有数据则显示登录 10.服务器访问数据库报错问题解决:因为引用的jar包的版本与之对应的MySQL数据库的版本不一致，5.0的jar包数据驱动是：com.mysql.jdbc.Driver8.0的jar包数据驱动是：com.mysql.cj.jdbc.Driver 11.怎么判断管理员是锁屏和退出登录解决:当管理员登录的时候会把账号和密码保存到session里面，锁屏则把保存session里面的密码清楚，退出登录则清空账号密码。代码实现： Object admin = ((HttpServletRequest) request).getSession().getAttribute(\"admin\"); //取学号 Object pwd = ((HttpServletRequest) request).getSession().getAttribute(\"pwd\"); //取密码 if(admin!=null&&pwd!=null){//判断学号和密码是否为空 chain.doFilter(request, response);//放行 }else if(admin!=null&&pwd==null){ ((HttpServletResponse) response).sendRedirect(\"/librarySystem/lockscreen.html\"); //密码为空则跳转到锁屏页面 }else{ ((HttpServletResponse) response).sendRedirect(\"/librarySystem/login.html\"); //账号密码都为空跳转到登录页面 }","categories":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/categories/jsp/"}],"tags":[{"name":"-jsp -bug -ajax","slug":"jsp-bug-ajax","permalink":"http://yoursite.com/tags/jsp-bug-ajax/"}]},{"title":"自学vue第五天","slug":"自学vue第五天","date":"2019-11-25T09:36:48.000Z","updated":"2019-12-05T10:08:52.936Z","comments":true,"path":"2019/11/25/自学vue第五天/","link":"","permalink":"http://yoursite.com/2019/11/25/自学vue第五天/","excerpt":"","text":"Vue.js - Webpack在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程 webpack官网 webpack安装的两种方式 运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 运行npm init初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑： // 导入jquery类库 import $ from 'jquery' // 设置偶数行背景色，索引从0开始，0是偶数 $('#list li:even').css('backgroundColor','lightblue'); // 设置奇数行背景色 $('#list li:odd').css('backgroundColor','pink'); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理： webpack src/js/main.js dist/bundle.js 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径： // 导入处理路径的模块 var path = require('path'); // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理 module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 } } 实现webpack的实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：\"dev\": \"webpack-dev-server --contentBase src\" 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下： // 导入处理路径的模块 var path = require('path'); // 导入自动生成HTMl文件的插件 var htmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 }, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin({ template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 }) ] } 修改package.json中script节点中的dev指令如下： \"dev\": \"webpack-dev-server\" 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1： 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：\"dev\": \"webpack-dev-server --hot --port 4321 --open\" 方式2： 修改webpack.config.js文件，新增devServer节点如下：devServer:{ hot:true, open:true, port:4321 } 在头部引入webpack模块：var webpack = require('webpack'); 在plugins节点下新增：new webpack.HotModuleReplacementPlugin() 使用webpack打包css文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件：module: { // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 { test: /\\.css$/, use: ['style-loader', 'css-loader'] }//处理css文件的规则 ] } 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的； 使用webpack打包less文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件：{ test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }, 使用webpack打包sass文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理sass文件的loader模块：{ test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] } 使用webpack处理css中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块：{ test: /\\.(png|jpg|gif)$/, use: 'url-loader' } 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：{ test: /\\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' }, 使用babel处理高级JS语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev安装babel的相关loader包 运行cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项：{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ } 在项目根目录中添加.babelrc文件，并修改这个配置文件如下：{ \"presets\":[\"es2015\", \"stage-0\"], \"plugins\":[\"transform-runtime\"] } 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的ES相关的语法； 相关文章babel-preset-env：你需要的唯一Babel插件Runtime transform 运行时编译es6","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"-vue -学习","slug":"vue-学习","permalink":"http://yoursite.com/tags/vue-学习/"}]},{"title":"自学vue第四天","slug":"自学vue第四天","date":"2019-11-24T09:36:48.000Z","updated":"2019-12-05T10:08:56.683Z","comments":true,"path":"2019/11/24/自学vue第四天/","link":"","permalink":"http://yoursite.com/2019/11/24/自学vue第四天/","excerpt":"","text":"Vue.js父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据&lt;script> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { msg: '这是父组件中的消息' }, components: { son: { template: '&lt;h1>这是子组件 --- {{finfo}}&lt;/h1>', props: ['finfo'] } } }); &lt;/script> 使用v-bind或简化指令，将数据传递到子组件中：&lt;div id=\"app\"> &lt;son :finfo=\"msg\">&lt;/son> &lt;/div> 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 &lt;son @func=\"getMsg\">&lt;/son> 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 &lt;div id=\"app\"> &lt;!-- 引用父组件 --> &lt;son @func=\"getMsg\">&lt;/son> &lt;!-- 组件模板定义 --> &lt;script type=\"x-template\" id=\"son\"> &lt;div> &lt;input type=\"button\" value=\"向父组件传值\" @click=\"sendMsg\" /> &lt;/div> &lt;/script> &lt;/div> &lt;script> // 子组件的定义方式 Vue.component('son', { template: '#son', // 组件模板Id methods: { sendMsg() { // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); } } }); &lt;/script> 组件中data和props的区别评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件 &lt;div id=\"app\"> &lt;div> &lt;input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" /> &lt;!-- 使用 ref 获取元素 --> &lt;h1 ref=\"myh1\">这是一个大大的H1&lt;/h1> &lt;hr> &lt;!-- 使用 ref 获取子组件 --> &lt;my-com ref=\"mycom\">&lt;/my-com> &lt;/div> &lt;/div> &lt;script> Vue.component('my-com', { template: '&lt;h5>这是一个子组件&lt;/h5>', data() { return { name: '子组件' } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getElement() { // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); } } }); &lt;/script> 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： &lt;!-- 1. 导入 vue-router 组件类库 --> &lt;script src=\"./lib/vue-router-2.7.0.js\">&lt;/script> 使用 router-link 组件来导航 &lt;!-- 2. 使用 router-link 组件来导航 --> &lt;router-link to=\"/login\">登录&lt;/router-link> &lt;router-link to=\"/register\">注册&lt;/router-link> 使用 router-view 组件来显示匹配到的组件 &lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --> &lt;router-view>&lt;/router-view> 创建使用Vue.extend创建组件 // 4.1 使用 Vue.extend 来创建登录组件 var login = Vue.extend({ template: '&lt;h1>登录组件&lt;/h1>' }); // 4.2 使用 Vue.extend 来创建注册组件 var register = Vue.extend({ template: '&lt;h1>注册组件&lt;/h1>' }); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 // 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter({ routes: [ { path: '/login', component: login }, { path: '/register', component: register } ] }); 使用 router 属性来使用路由规则 // 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', router: router // 使用 router 属性来使用路由规则 }); 使用tag属性指定router-link渲染的标签类型设置路由重定向设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数：{ path: '/register/:id', component: register } 通过 this.$route.params来获取路由中的参数：var register = Vue.extend({ template: '&lt;h1>注册组件 --- {{this.$route.params.id}}&lt;/h1>' }); 使用 children 属性实现路由嵌套 &lt;div id=\"app\"> &lt;router-link to=\"/account\">Account&lt;/router-link> &lt;router-view>&lt;/router-view> &lt;/div> &lt;script> // 父路由中的组件 const account = Vue.extend({ template: `&lt;div> 这是account组件 &lt;router-link to=\"/account/login\">login&lt;/router-link> | &lt;router-link to=\"/account/register\">register&lt;/router-link> &lt;router-view>&lt;/router-view> &lt;/div>` }); // 子路由中的 login 组件 const login = Vue.extend({ template: '&lt;div>登录组件&lt;/div>' }); // 子路由中的 register 组件 const register = Vue.extend({ template: '&lt;div>注册组件&lt;/div>' }); // 路由实例 var router = new VueRouter({ routes: [ { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向 { path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符 { path: 'register', component: register } ] } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { account }, router: router }); &lt;/script> 命名视图实现经典布局 标签代码结构： &lt;div id=\"app\"> &lt;router-view>&lt;/router-view> &lt;div class=\"content\"> &lt;router-view name=\"a\">&lt;/router-view> &lt;router-view name=\"b\">&lt;/router-view> &lt;/div> &lt;/div> JS代码： &lt;script> var header = Vue.component('header', { template: '&lt;div class=\"header\">header&lt;/div>' }); var sidebar = Vue.component('sidebar', { template: '&lt;div class=\"sidebar\">sidebar&lt;/div>' }); var mainbox = Vue.component('mainbox', { template: '&lt;div class=\"mainbox\">mainbox&lt;/div>' }); // 创建路由对象 var router = new VueRouter({ routes: [ { path: '/', components: { default: header, a: sidebar, b: mainbox } } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router }); &lt;/script> CSS 样式： &lt;style> .header { border: 1px solid red; } .content{ display: flex; } .sidebar { flex: 2; border: 1px solid green; height: 500px; } .mainbox{ flex: 8; border: 1px solid blue; height: 500px; } &lt;/style> watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： &lt;div id=\"app\"> &lt;input type=\"text\" v-model=\"firstName\"> + &lt;input type=\"text\" v-model=\"lastName\"> = &lt;span>{{fullName}}&lt;/span> &lt;/div> &lt;script> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' }, methods: {}, watch: { 'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; }, 'lastName': function (newVal, oldVal) { this.fullName = this.firstName + ' - ' + newVal; } } }); &lt;/script> 监听路由对象的改变： &lt;div id=\"app\"> &lt;router-link to=\"/login\">登录&lt;/router-link> &lt;router-link to=\"/register\">注册&lt;/router-link> &lt;router-view>&lt;/router-view> &lt;/div> &lt;script> var login = Vue.extend({ template: '&lt;h1>登录组件&lt;/h1>' }); var register = Vue.extend({ template: '&lt;h1>注册组件&lt;/h1>' }); var router = new VueRouter({ routes: [ { path: \"/login\", component: login }, { path: \"/register\", component: register } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router: router, watch: { '$route': function (newVal, oldVal) { if (newVal.path === '/login') { console.log('这是登录组件'); } } } }); &lt;/script> computed计算属性的使用 默认只有getter的计算属性： &lt;div id=\"app\"> &lt;input type=\"text\" v-model=\"firstName\"> + &lt;input type=\"text\" v-model=\"lastName\"> = &lt;span>{{fullName}}&lt;/span> &lt;/div> &lt;script> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: {}, computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() { return this.firstName + ' - ' + this.lastName; } } }); &lt;/script> 定义有getter和setter的计算属性： &lt;div id=\"app\"> &lt;input type=\"text\" v-model=\"firstName\"> &lt;input type=\"text\" v-model=\"lastName\"> &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --> &lt;input type=\"button\" value=\"修改fullName\" @click=\"changeName\"> &lt;span>{{fullName}}&lt;/span> &lt;/div> &lt;script> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: { changeName() { this.fullName = 'TOM - chen2'; } }, computed: { fullName: { get: function () { return this.firstName + ' - ' + this.lastName; }, set: function (newVal) { var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; } } } }); &lt;/script> watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"-vue -学习","slug":"vue-学习","permalink":"http://yoursite.com/tags/vue-学习/"}]},{"title":"自学vue第三天","slug":"自学vue第三天","date":"2019-11-23T09:36:48.000Z","updated":"2019-12-05T10:09:00.739Z","comments":true,"path":"2019/11/23/自学vue第三天/","link":"","permalink":"http://yoursite.com/2019/11/23/自学vue第三天/","excerpt":"","text":"Vue.js定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法：var login = Vue.extend({ template: '&lt;h1>登录&lt;/h1>' }); Vue.component('login', login); 直接使用 Vue.component 方法：Vue.component('register', { template: '&lt;h1>注册&lt;/h1>' }); 将模板字符串，定义到script标签种：&lt;script id=\"tmpl\" type=\"x-template\"> &lt;div>&lt;a href=\"#\">登录&lt;/a> | &lt;a href=\"#\">注册&lt;/a>&lt;/div> &lt;/script> 同时，需要使用 Vue.component 来定义组件：Vue.component('account', { template: '#tmpl' }); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如：Vue.component('account', { template: '#tmpl', data() { return { msg: '大家好！' } }, methods:{ login(){ alert('点击了登录按钮'); } } }); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象 通过计数器案例演示 使用components属性定义局部子组件 组件实例定义方式：&lt;script> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { // 定义子组件 account: { // account 组件 template: '&lt;div>&lt;h1>这是Account组件{{name}}&lt;/h1>&lt;login>&lt;/login>&lt;/div>', // 在这里使用定义的子组件 components: { // 定义子组件的子组件 login: { // login 组件 template: \"&lt;h3>这是登录组件&lt;/h3>\" } } } } }); &lt;/script> 引用组件：&lt;div id=\"app\"> &lt;account>&lt;/account> &lt;/div> 使用flag标识符结合v-if和v-else切换组件 页面结构： &lt;div id=\"app\"> &lt;input type=\"button\" value=\"toggle\" @click=\"flag=!flag\"> &lt;my-com1 v-if=\"flag\">&lt;/my-com1> &lt;my-com2 v-else=\"flag\">&lt;/my-com2> &lt;/div> Vue实例定义： &lt;script> Vue.component('myCom1', { template: '&lt;h3>奔波霸&lt;/h3>' }) Vue.component('myCom2', { template: '&lt;h3>霸波奔&lt;/h3>' }) // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { flag: true }, methods: {} }); &lt;/script> 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： // 登录组件 const login = Vue.extend({ template: `&lt;div> &lt;h3>登录组件&lt;/h3> &lt;/div>` }); Vue.component('login', login); // 注册组件 const register = Vue.extend({ template: `&lt;div> &lt;h3>注册组件&lt;/h3> &lt;/div>` }); Vue.component('register', register); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { comName: 'login' }, methods: {} }); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： &lt;div id=\"app\"> &lt;a href=\"#\" @click.prevent=\"comName='login'\">登录&lt;/a> &lt;a href=\"#\" @click.prevent=\"comName='register'\">注册&lt;/a> &lt;hr> &lt;transition mode=\"out-in\"> &lt;component :is=\"comName\">&lt;/component> &lt;/transition> &lt;/div> 添加切换样式： &lt;style> .v-enter, .v-leave-to { opacity: 0; transform: translateX(30px); } .v-enter-active, .v-leave-active { position: absolute; transition: all 0.3s ease; } h3{ margin: 0; } &lt;/style> 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据&lt;script> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { msg: '这是父组件中的消息' }, components: { son: { template: '&lt;h1>这是子组件 --- {{finfo}}&lt;/h1>', props: ['finfo'] } } }); &lt;/script> 使用v-bind或简化指令，将数据传递到子组件中：&lt;div id=\"app\"> &lt;son :finfo=\"msg\">&lt;/son> &lt;/div> 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 &lt;son @func=\"getMsg\">&lt;/son> 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 &lt;div id=\"app\"> &lt;!-- 引用父组件 --> &lt;son @func=\"getMsg\">&lt;/son> &lt;!-- 组件模板定义 --> &lt;script type=\"x-template\" id=\"son\"> &lt;div> &lt;input type=\"button\" value=\"向父组件传值\" @click=\"sendMsg\" /> &lt;/div> &lt;/script> &lt;/div> &lt;script> // 子组件的定义方式 Vue.component('son', { template: '#son', // 组件模板Id methods: { sendMsg() { // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); } } }); &lt;/script> 评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件 &lt;div id=\"app\"> &lt;div> &lt;input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" /> &lt;!-- 使用 ref 获取元素 --> &lt;h1 ref=\"myh1\">这是一个大大的H1&lt;/h1> &lt;hr> &lt;!-- 使用 ref 获取子组件 --> &lt;my-com ref=\"mycom\">&lt;/my-com> &lt;/div> &lt;/div> &lt;script> Vue.component('my-com', { template: '&lt;h5>这是一个子组件&lt;/h5>', data() { return { name: '子组件' } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getElement() { // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); } } }); &lt;/script> 什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： &lt;!-- 1. 导入 vue-router 组件类库 --> &lt;script src=\"./lib/vue-router-2.7.0.js\">&lt;/script> 使用 router-link 组件来导航 &lt;!-- 2. 使用 router-link 组件来导航 --> &lt;router-link to=\"/login\">登录&lt;/router-link> &lt;router-link to=\"/register\">注册&lt;/router-link> 使用 router-view 组件来显示匹配到的组件 &lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --> &lt;router-view>&lt;/router-view> 创建使用Vue.extend创建组件 // 4.1 使用 Vue.extend 来创建登录组件 var login = Vue.extend({ template: '&lt;h1>登录组件&lt;/h1>' }); // 4.2 使用 Vue.extend 来创建注册组件 var register = Vue.extend({ template: '&lt;h1>注册组件&lt;/h1>' }); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 // 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter({ routes: [ { path: '/login', component: login }, { path: '/register', component: register } ] }); 使用 router 属性来使用路由规则 // 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', router: router // 使用 router 属性来使用路由规则 }); 设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数：{ path: '/register/:id', component: register } 通过 this.$route.params来获取路由中的参数：var register = Vue.extend({ template: '&lt;h1>注册组件 --- {{this.$route.params.id}}&lt;/h1>' }); 使用 children 属性实现路由嵌套 &lt;div id=\"app\"> &lt;router-link to=\"/account\">Account&lt;/router-link> &lt;router-view>&lt;/router-view> &lt;/div> &lt;script> // 父路由中的组件 const account = Vue.extend({ template: `&lt;div> 这是account组件 &lt;router-link to=\"/account/login\">login&lt;/router-link> | &lt;router-link to=\"/account/register\">register&lt;/router-link> &lt;router-view>&lt;/router-view> &lt;/div>` }); // 子路由中的 login 组件 const login = Vue.extend({ template: '&lt;div>登录组件&lt;/div>' }); // 子路由中的 register 组件 const register = Vue.extend({ template: '&lt;div>注册组件&lt;/div>' }); // 路由实例 var router = new VueRouter({ routes: [ { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向 { path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符 { path: 'register', component: register } ] } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { account }, router: router }); &lt;/script> 命名视图实现经典布局 标签代码结构： &lt;div id=\"app\"> &lt;router-view>&lt;/router-view> &lt;div class=\"content\"> &lt;router-view name=\"a\">&lt;/router-view> &lt;router-view name=\"b\">&lt;/router-view> &lt;/div> &lt;/div> JS代码： &lt;script> var header = Vue.component('header', { template: '&lt;div class=\"header\">header&lt;/div>' }); var sidebar = Vue.component('sidebar', { template: '&lt;div class=\"sidebar\">sidebar&lt;/div>' }); var mainbox = Vue.component('mainbox', { template: '&lt;div class=\"mainbox\">mainbox&lt;/div>' }); // 创建路由对象 var router = new VueRouter({ routes: [ { path: '/', components: { default: header, a: sidebar, b: mainbox } } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router }); &lt;/script> CSS 样式： &lt;style> .header { border: 1px solid red; } .content{ display: flex; } .sidebar { flex: 2; border: 1px solid green; height: 500px; } .mainbox{ flex: 8; border: 1px solid blue; height: 500px; } &lt;/style> watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： &lt;div id=\"app\"> &lt;input type=\"text\" v-model=\"firstName\"> + &lt;input type=\"text\" v-model=\"lastName\"> = &lt;span>{{fullName}}&lt;/span> &lt;/div> &lt;script> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' }, methods: {}, watch: { 'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; }, 'lastName': function (newVal, oldVal) { this.fullName = this.firstName + ' - ' + newVal; } } }); &lt;/script> 监听路由对象的改变： &lt;div id=\"app\"> &lt;router-link to=\"/login\">登录&lt;/router-link> &lt;router-link to=\"/register\">注册&lt;/router-link> &lt;router-view>&lt;/router-view> &lt;/div> &lt;script> var login = Vue.extend({ template: '&lt;h1>登录组件&lt;/h1>' }); var register = Vue.extend({ template: '&lt;h1>注册组件&lt;/h1>' }); var router = new VueRouter({ routes: [ { path: \"/login\", component: login }, { path: \"/register\", component: register } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router: router, watch: { '$route': function (newVal, oldVal) { if (newVal.path === '/login') { console.log('这是登录组件'); } } } }); &lt;/script> computed计算属性的使用 默认只有getter的计算属性： &lt;div id=\"app\"> &lt;input type=\"text\" v-model=\"firstName\"> + &lt;input type=\"text\" v-model=\"lastName\"> = &lt;span>{{fullName}}&lt;/span> &lt;/div> &lt;script> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: {}, computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() { return this.firstName + ' - ' + this.lastName; } } }); &lt;/script> 定义有getter和setter的计算属性： &lt;div id=\"app\"> &lt;input type=\"text\" v-model=\"firstName\"> &lt;input type=\"text\" v-model=\"lastName\"> &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --> &lt;input type=\"button\" value=\"修改fullName\" @click=\"changeName\"> &lt;span>{{fullName}}&lt;/span> &lt;/div> &lt;script> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: { changeName() { this.fullName = 'TOM - chen2'; } }, computed: { fullName: { get: function () { return this.firstName + ' - ' + this.lastName; }, set: function (newVal) { var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; } } } }); &lt;/script> watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"-vue -学习","slug":"vue-学习","permalink":"http://yoursite.com/tags/vue-学习/"}]},{"title":"自学vue第二天","slug":"自学vue第二天","date":"2019-11-22T09:36:48.000Z","updated":"2019-12-05T09:58:22.859Z","comments":true,"path":"2019/11/22/自学vue第二天/","link":"","permalink":"http://yoursite.com/2019/11/22/自学vue第二天/","excerpt":"","text":"Vue.js品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 &lt;tr v-for=\"item in list | filterBy searchName in 'name'\"> &lt;td>{{item.id}}&lt;/td> &lt;td>{{item.name}}&lt;/td> &lt;td>{{item.ctime}}&lt;/td> &lt;td> &lt;a href=\"#\" @click.prevent=\"del(item.id)\">删除&lt;/a> &lt;/td> &lt;/tr> 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： &lt;hr> 输入筛选名称： &lt;input type=\"text\" v-model=\"searchName\"> 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： &lt;tbody> &lt;tr v-for=\"item in search(searchName)\"> &lt;td>{{item.id}}&lt;/td> &lt;td>{{item.name}}&lt;/td> &lt;td>{{item.ctime}}&lt;/td> &lt;td> &lt;a href=\"#\" @click.prevent=\"del(item.id)\">删除&lt;/a> &lt;/td> &lt;/tr> &lt;/tbody> search 过滤方法中，使用 数组的 filter 方法进行过滤： search(name) { return this.list.filter(x => { return x.name.indexOf(name) != -1; }); } Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： &lt;td>{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td> 私有 filters 定义方式： filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = \"\") { // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; } } } 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器 // 定义一个全局过滤器 Vue.filter('dataFormat', function (input, pattern = '') { var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; } }); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】 Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： &lt;input type=\"text\" v-model=\"name\" @keyup.f2=\"add\"> 自定义指令 自定义全局和局部的 自定义指令： // 自定义全局指令 v-focus，为绑定的元素自动获取焦点： Vue.directive('focus', { inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用 el.focus(); } }); // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: { color: { // 为元素设置指定的字体颜色 bind(el, binding) { el.style.color = binding.value; } }, 'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; } } 自定义指令的使用方式： &lt;input type=\"text\" v-model=\"searchName\" v-focus v-color=\"'red'\" v-font-weight=\"900\"> Vue 1.x 中 自定义元素指令【已废弃,了解即可】Vue.elementDirective('red-color', { bind: function () { this.el.style.color = 'red'; } }); 使用方式： &lt;red-color>1232&lt;/red-color> vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子； const http = require('http'); // 导入解析 URL 地址的核心模块 const urlModule = require('url'); const server = http.createServer(); // 监听 服务器的 request 请求事件，处理每个请求 server.on('request', (req, res) => { const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') { // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = { name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] } // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `${cbName}(${JSON.stringify(data)})`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); } else { res.end('404'); } }); server.listen(3000, () => { console.log('server running at http://127.0.0.1:3000'); }); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： getInfo() { // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res => { console.log(res.body); }) } 发送post请求： postInfo() { var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, { name: 'zs' }, { emulateJSON: true }).then(res => { console.log(res.body); }); } 发送JSONP请求获取数据： jsonpInfo() { // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res => { console.log(res.body); }); } 配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root 品牌管理改造展示品牌列表添加品牌数据删除品牌数据Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构： &lt;div id=\"app\"> &lt;input type=\"button\" value=\"动起来\" @click=\"myAnimate\"> &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --> &lt;transition name=\"fade\"> &lt;div v-show=\"isshow\">动画哦&lt;/div> &lt;/transition> &lt;/div> VM 实例： // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { isshow: false }, methods: { myAnimate() { this.isshow = !this.isshow; } } }); 定义两组类样式： /* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active { transition: all 0.2s ease; position: absolute; } /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to { opacity: 0; transform: translateX(100px); } 使用第三方 CSS 动画库 导入动画类库：&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./lib/animate.css\"> 定义 transition 及属性：&lt;transition enter-active-class=\"fadeInRight\" leave-active-class=\"fadeOutRight\" :duration=\"{ enter: 500, leave: 800 }\"> &lt;div class=\"animated\" v-show=\"isshow\">动画哦&lt;/div> &lt;/transition> 使用动画钩子函数 定义 transition 组件以及三个钩子函数：&lt;div id=\"app\"> &lt;input type=\"button\" value=\"切换动画\" @click=\"isshow = !isshow\"> &lt;transition @before-enter=\"beforeEnter\" @enter=\"enter\" @after-enter=\"afterEnter\"> &lt;div v-if=\"isshow\" class=\"show\">OK&lt;/div> &lt;/transition> &lt;/div> 定义三个 methods 钩子方法：methods: { beforeEnter(el) { // 动画进入之前的回调 el.style.transform = 'translateX(500px)'; }, enter(el, done) { // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = 'translateX(0px)'; done(); }, afterEnter(el) { // 动画进入完成之后的回调 this.isshow = !this.isshow; } } 定义动画过渡时长和样式：.show{ transition: all 0.4s ease; } v-for 的列表过渡 定义过渡样式： &lt;style> .list-enter, .list-leave-to { opacity: 0; transform: translateY(10px); } .list-enter-active, .list-leave-active { transition: all 0.3s ease; } &lt;/style> 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： &lt;div id=\"app\"> &lt;input type=\"text\" v-model=\"txt\" @keyup.enter=\"add\"> &lt;transition-group tag=\"ul\" name=\"list\"> &lt;li v-for=\"(item, i) in list\" :key=\"i\">{{item}}&lt;/li> &lt;/transition-group> &lt;/div> 定义 VM中的结构： // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { txt: '', list: [1, 2, 3, 4] }, methods: { add() { this.list.push(this.txt); this.txt = ''; } } }); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：.v-move{ transition: all 0.8s ease; } .v-leave-active{ position: absolute; } 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"-vue -学习","slug":"vue-学习","permalink":"http://yoursite.com/tags/vue-学习/"}]},{"title":"自学vue第一天","slug":"自学vue第一天","date":"2019-11-21T09:36:48.000Z","updated":"2019-12-05T09:52:45.833Z","comments":true,"path":"2019/11/21/自学vue第一天/","link":"","permalink":"http://yoursite.com/2019/11/21/自学vue第一天/","excerpt":"","text":"Vue.js什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： &lt;div id=\"app\"> &lt;p>{{info}}&lt;/p> &lt;input type=\"button\" value=\"开启\" v-on:click=\"go\"> &lt;input type=\"button\" value=\"停止\" v-on:click=\"stop\"> &lt;/div> Vue实例： // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { info: '猥琐发育，别浪~！', intervalId: null }, methods: { go() { // 如果当前有定时器在运行，则直接return if (this.intervalId != null) { return; } // 开始定时器 this.intervalId = setInterval(() => { this.info = this.info.substring(1) + this.info.substring(0, 1); }, 500); }, stop() { clearInterval(this.intervalId); } } }); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 &lt;div id=\"app\"> &lt;input type=\"text\" v-model=\"n1\"> &lt;select v-model=\"opt\"> &lt;option value=\"0\">+&lt;/option> &lt;option value=\"1\">-&lt;/option> &lt;option value=\"2\">*&lt;/option> &lt;option value=\"3\">÷&lt;/option> &lt;/select> &lt;input type=\"text\" v-model=\"n2\"> &lt;input type=\"button\" value=\"=\" v-on:click=\"getResult\"> &lt;input type=\"text\" v-model=\"result\"> &lt;/div> Vue实例代码： // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { n1: 0, n2: 0, result: 0, opt: '0' }, methods: { getResult() { switch (this.opt) { case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; } } } }); 在Vue中使用样式使用class样式 数组 &lt;h1 :class=\"['red', 'thin']\">这是一个邪恶的H1&lt;/h1> 数组中使用三元表达式 &lt;h1 :class=\"['red', 'thin', isactive?'active':'']\">这是一个邪恶的H1&lt;/h1> 数组中嵌套对象 &lt;h1 :class=\"['red', 'thin', {'active': isactive}]\">这是一个邪恶的H1&lt;/h1> 直接使用对象 &lt;h1 :class=\"{red:true, italic:true, active:true, thin:true}\">这是一个邪恶的H1&lt;/h1> 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 &lt;h1 :style=\"{color: 'red', 'font-size': '40px'}\">这是一个善良的H1&lt;/h1> 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式：data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' } } 在元素中，通过属性绑定的形式，将样式对象应用到元素中：&lt;h1 :style=\"h1StyleObj\">这是一个善良的H1&lt;/h1> 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式：data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }, h1StyleObj2: { fontStyle: 'italic' } } 在元素中，通过属性绑定的形式，将样式对象应用到元素中：&lt;h1 :style=\"[h1StyleObj, h1StyleObj2]\">这是一个善良的H1&lt;/h1> Vue指令之v-for和key属性 迭代数组 &lt;ul> &lt;li v-for=\"(item, i) in list\">索引：{{i}} --- 姓名：{{item.name}} --- 年龄：{{item.age}}&lt;/li> &lt;/ul> 迭代对象中的属性 &lt;!-- 循环遍历对象身上的属性 --> &lt;div v-for=\"(val, key, i) in userInfo\">{{val}} --- {{key}} --- {{i}}&lt;/div> 迭代数字 &lt;p v-for=\"i in 10\">这是第 {{i}} 个P标签&lt;/p> 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 &lt;tr v-for=\"item in list | filterBy searchName in 'name'\"> &lt;td>{{item.id}}&lt;/td> &lt;td>{{item.name}}&lt;/td> &lt;td>{{item.ctime}}&lt;/td> &lt;td> &lt;a href=\"#\" @click.prevent=\"del(item.id)\">删除&lt;/a> &lt;/td> &lt;/tr> 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： &lt;hr> 输入筛选名称： &lt;input type=\"text\" v-model=\"searchName\"> 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： &lt;tbody> &lt;tr v-for=\"item in search(searchName)\"> &lt;td>{{item.id}}&lt;/td> &lt;td>{{item.name}}&lt;/td> &lt;td>{{item.ctime}}&lt;/td> &lt;td> &lt;a href=\"#\" @click.prevent=\"del(item.id)\">删除&lt;/a> &lt;/td> &lt;/tr> &lt;/tbody> search 过滤方法中，使用 数组的 filter 方法进行过滤： search(name) { return this.list.filter(x => { return x.name.indexOf(name) != -1; }); } Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： &lt;td>{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td> 私有 filters 定义方式： filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = \"\") { // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; } } } 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器 // 定义一个全局过滤器 Vue.filter('dataFormat', function (input, pattern = '') { var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; } }); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】 Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： &lt;input type=\"text\" v-model=\"name\" @keyup.f2=\"add\"> 自定义指令 自定义全局和局部的 自定义指令： // 自定义全局指令 v-focus，为绑定的元素自动获取焦点： Vue.directive('focus', { inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用 el.focus(); } }); // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: { color: { // 为元素设置指定的字体颜色 bind(el, binding) { el.style.color = binding.value; } }, 'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; } } 自定义指令的使用方式： &lt;input type=\"text\" v-model=\"searchName\" v-focus v-color=\"'red'\" v-font-weight=\"900\"> Vue 1.x 中 自定义元素指令【已废弃,了解即可】Vue.elementDirective('red-color', { bind: function () { this.el.style.color = 'red'; } }); 使用方式： &lt;red-color>1232&lt;/red-color> 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"-vue -学习","slug":"vue-学习","permalink":"http://yoursite.com/tags/vue-学习/"}]},{"title":"SQL语法","slug":"SQL语法","date":"2019-10-22T02:54:39.000Z","updated":"2019-10-22T09:45:40.001Z","comments":true,"path":"2019/10/22/SQL语法/","link":"","permalink":"http://yoursite.com/2019/10/22/SQL语法/","excerpt":"","text":"1.数据库基础语法创建数据库create database 数据库名; 删除数据库drop database 数据库名; 选择数据库use 数据库名; 2.表的约束主键约束primary key 主键自增auto_increment primary key 外键约束命名写法：constraint 外键约束的名称foreign key(teaid)//将从表中的teaid设为外键references student(teaid);关联student表的teaid主键增加外键约束alter table 表名add constraint 外键约束的名称foreign key(teaid)//将从表中的teaid设为外键references student(teaid);关联student表的teaid主键不命名写法：alter table 表名 add foreign key(外键) references 从表(外键); 非空约束not null 默认约束default 默认值 唯一约束unique 3.操作表的结构创建表create table 表名(字段名1 类型1 约束,...); 修改表名rename table 旧表名 to 新表名 修改表结构alter table 表名 动作 动作修改字段类型：modify 字段名 新类型修改字段名：change 老字段名 新字段名 新字段类型添加字段:add 字段名 字段类型删除字段:drop 字段名 删除表dorp table 表名 查看表结构desc 表名; 4.操作表的数据插入数据insert into 表名(字段一,...) values(值一,...); 更新语句update 表名 set 字段一 = 值一,... where 条件 删除语句delete from 表名 where 条件注意：先删除从表记录，再删除主表记录 清空语句delete from 表名truncate table 表名区别：truncate将重置auto_increment不可恢复数据 查询语句select 字段名 聚合函数from 表名where 条件order by 字段名 asc/desclimit 字段名 限制行数group by 字段名having 条件 //主要解决条件语句不能用聚合函数问题 常用模糊查询where 字段名 like &#39;值&#39; * 任意字符串 % 表示任意长度的字符，0也是任意长度 _ 表示只有一个字符 常用聚合函数 sum（字段名） 求和 max（字段名） 最大数 min（字段名） 最小值 avg（字段名） 平均数 count（字段名） 个数 count（字段名）和count（*）区别就是：count（字段名）如果字段有null值，则不计数 多表查询内连接select 字段一，字段二，...from 表一 inner join 表二 on 条件; 左连接select 字段一，字段二，...from 表一 left join 表二 on 条件； 右连接select 字段一，字段二，...from 表一 right join 表二 on 条件；","categories":[],"tags":[{"name":"-语法 -SQL","slug":"语法-SQL","permalink":"http://yoursite.com/tags/语法-SQL/"}]},{"title":"ArrayList总结","slug":"ArrayList总结","date":"2019-10-19T12:45:18.000Z","updated":"2019-10-19T13:06:03.544Z","comments":true,"path":"2019/10/19/ArrayList总结/","link":"","permalink":"http://yoursite.com/2019/10/19/ArrayList总结/","excerpt":"","text":"ArrayList1.底层是利用（动态）数组形式实现 1.52.如何构建一个ArrayList对象无参构造方法 带默认容量的构造方法List&lt;String&gt; list=new ArrayList&lt;String&gt;(); 3.常用方法增 add（E e）删 remove（index）改 set（index value）查 get（index）长度 size（） 泛型：用来规定数据类型注意：泛型 造型在类或接口描述的时候 可以使用某种符号来表示一个未知的类型在类型使用的时候 需要一个具体类型来代替注意：泛型需要使用应用数据类型来代替1.泛型类 2.泛型接口 3.泛型方法 4.方法参数泛型限制 Vector类1.是ArrayList集合早期版本线程同步 安全性高 效率 2.扩容方式不同2倍 可通过构造方法创建对象时修改这一机制","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"-泛型 -Vector -ArrayList","slug":"泛型-Vector-ArrayList","permalink":"http://yoursite.com/tags/泛型-Vector-ArrayList/"}]},{"title":"Set总结","slug":"Set总结","date":"2019-10-19T12:45:02.000Z","updated":"2019-10-23T00:47:27.061Z","comments":true,"path":"2019/10/19/Set总结/","link":"","permalink":"http://yoursite.com/2019/10/19/Set总结/","excerpt":"","text":"SetCollection 以value形式存在Set 无序无重复 1.具体实现类HashSetTreeSet 2.基本的使用3.无序 无重复无序：我们使用集合存放的顺序 集合内取出来的顺序不一致集合本身是有自己的算法排布顺序 hash算法 HashSet---&gt;（HashMap 数组+链表 散链表）1.java.utill2.如何创建对象 无参数 有参数HashSet&lt;String&gt; set =new HashSet&lt;String&gt;(); 3.集合容器的基本使用 增 add(value) addAall(collection c) retainAll removeAll 并集 交集 差集 删 boolean = remove(Objest) 改 没有 查 增强for循环集合遍历 for(String v:set){ System.out.println(v); } //迭代器： Iterator&lt;String> it = set.iterator(); //判断下一个位置是否有元素 while(it.hasNext()){ String value = it.next(); System.out.println(value); }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"-Set","slug":"Set","permalink":"http://yoursite.com/tags/Set/"}]},{"title":"Map总结","slug":"Map总结","date":"2019-10-19T12:44:45.000Z","updated":"2019-10-19T13:31:14.176Z","comments":true,"path":"2019/10/19/Map总结/","link":"","permalink":"http://yoursite.com/2019/10/19/Map总结/","excerpt":"","text":"https://docs.oracle.com/javase/8/docs/api/ Map映射 通过某一个key可以直接定位到value值存储的方式：键值对 存储 key-valuekey无序无重复 value无序可重复 map基本使用：HashMapHashSetHashtable##HashMap: 1.包 java.util2.如何创建对象HashMap&lt;Integer,String&gt; hashmap = new HashMap&lt;Integer,String&gt;(); 3.基本方法 增 put（key,value）存储一组映射关系 key-value 删 E = remove（key; 改 replace(key,new value); 查 get(key); 遍历 //获取map集合的全部key Set&lt;Integer> keys = map.keySet(); //通过迭代器去遍历keys Iterator&lt;Integer> it = keys.iterator(); while(it.hasNext()){ Integer key = it.next(); String value = map.get(key); System.out.println(key+\"-\"+value); } size(); 4.除了上面的几个常用的方法可以去api去看5.map集合什么情况下用：1.想要存储一组元素数组 or 集合 如果存储的元素以后长度不变用数组，不确定用集合 2.如果发现长度以后不确定 –&gt;集合 List Set Map 有序 无重复 k-v ArrayList适合遍历 Hash性能高 Hash性能高 LinkedList适合插入删除 Tree希望自动去重和排序 Tree希望key自动排序 StackLIFO","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"-Map","slug":"Map","permalink":"http://yoursite.com/tags/Map/"}]},{"title":"SQL 函数","slug":"SQL函数","date":"2019-10-17T09:36:12.000Z","updated":"2019-10-17T10:59:01.561Z","comments":true,"path":"2019/10/17/SQL函数/","link":"","permalink":"http://yoursite.com/2019/10/17/SQL函数/","excerpt":"","text":"avg（）函数定义和用法AVG 函数返回数值列的平均值。NULL 值不包括在计算中。 SQL AVG() 语法select avg(字段名)as 新字段名 from 表名; 实例我们拥有下面这个stuinfo表： id date name age ach tuition sex 1 2019-10-17 17:44:45 亚索 18 84 10600 男 2 2018-10-17 17:45:42 寒冰 16 95 10600 女 3 2019-08-01 17:45:34 布隆 10 84 10000 男 4 2019-01-17 17:46:42 劫 23 99 500 男 5 2019-10-13 17:46:52 小鱼儿 45 84 6000 女 例子 1现在，我们希望计算 age 字段的平均值。 我们使用如下 SQL 语句：select avg(age)as avgAge from stuinfo;结果集类似这样： avgAge 22.4000 例子 2现在，我们希望找到 age 值高于 age 平均值的客户。我们使用如下 SQL 语句：select name from stuinfo where age&gt;(select avg(age) from stuinfo); name 劫 小鱼儿 count()语句COUNT() 函数返回匹配指定条件的行数。 COUNT(column_name)函数返回指定列的值的数目（NULL 不计入）：语法SELECT COUNT(column_name) FROM table_name COUNT(*)函数返回表中的记录数：SELECT COUNT(*) FROM table_name COUNT(DISTINCT column_name)函数返回指定列的不同值的数目：SELECT COUNT(DISTINCT column_name) FROM table_name 实例我们拥有下面这个stuinfo表： id date name age ach tuition sex 1 2019-10-17 17:44:45 亚索 18 84 10600 男 2 2018-10-17 17:45:42 寒冰 16 95 10600 女 3 2019-08-01 17:45:34 布隆 10 84 10000 男 4 2019-01-17 17:46:42 劫 23 99 500 男 5 2019-10-13 17:46:52 小鱼儿 45 84 6000 女 现在，我们希望计算学生 tuition 的10600学费总数。我们使用如下 SQL 语句：select count(tuition) as countTuition from stuinfo where tuition = 10600;以上 SQL 语句的结果是 2，因为学生 tuition 共有 2 人： countTuition 2 SQL COUNT(*) 实例如果我们省略 WHERE 子句，比如这样：select count(*) as count from stuinfo;结果集类似这样： count 5 这是表中的总行数。 SQL COUNT(DISTINCT column_name) 实例现在，我们希望计算 “stuinfo” 表中不同成绩的数目。我们使用如下 SQL 语句：select count(distinct ach) as numAch from stuinfo;结果集类似这样： numAch 3 max()函数MAX 函数返回一列中的最大值。NULL 值不包括在计算中。SQL MAX() 语法SELECT MAX(column_name) FROM table_name min()函数MIN 函数返回一列中的最小值。NULL 值不包括在计算中。SQL MIN() 语法SELECT MIN(column_name) FROM table_name注释：MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。 sum()函数SUM 函数返回数值列的总数（总额）。SQL SUM() 语法SELECT SUM(column_name) FROM table_name first()函数FIRST() 函数返回指定的字段中第一个记录的值。 提示：可使用 ORDER BY 语句对记录进行排序。SQL FIRST() 语法SELECT FIRST(column_name) FROM table_name list()函数LAST() 函数返回指定的字段中最后一个记录的值。 提示：可使用 ORDER BY 语句对记录进行排序。SQL LAST() 语法SELECT LAST(column_name) FROM table_name Group By函数GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。SQL GROUP BY 语法 SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name 实例我们拥有下面这个 “stuinfo” 表： id date name age ach tuition sex 1 2019-10-17 17:44:45 亚索 18 84 10600 男 2 2018-10-17 17:45:42 寒冰 16 95 10600 女 3 2019-08-01 17:45:34 布隆 10 84 10000 男 4 2019-01-17 17:46:42 劫 23 99 500 男 5 2019-10-13 17:46:52 小鱼儿 45 84 6000 女 现在我们希望查找男生和女生的总分数并想要使用 GROUP BY 进行组合。我们使用下列 SQL 语句：select sex,sum(ach) from stuinfo group by sex;结果： sex sum(ach) 女 179 男 267 Having();在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。SQL HAVING 语法 SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name HAVING aggregate_function(column_name) operator value","categories":[{"name":"SQL函数","slug":"SQL函数","permalink":"http://yoursite.com/categories/SQL函数/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"SQL基础","slug":"SQL总结","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-17T09:37:49.197Z","comments":true,"path":"2019/10/16/SQL总结/","link":"","permalink":"http://yoursite.com/2019/10/16/SQL总结/","excerpt":"","text":"SQL 语法数据库表一个数据库通常包含一个或多个表。每个表由一个名字标识（例如“客户”或者“订单”）。表包含带有数据的记录（行） SQL 语句您需要在数据库上执行的大部分工作都由 SQL 语句完成。下面的语句从表中选取 LastName 列的数据：SELECT LastName FROM Persons重要事项：SQL 对大小写不敏感！ SQL DML 和 DDL可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。 查询和更新指令构成了 SQL 的 DML 部分： SELECT - 从数据库表中获取数据 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。SQL 中最重要的 DDL 语句: CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL SELECT 语句SELECT 语句用于从表中选取数据。 结果被存储在一个结果表中（称为结果集）。 SQL SELECT 语法SELECT 列名称 FROM 表名称以及：SELECT * FROM 表名称 SQL SELECT DISTINCT 语句在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。 关键词 DISTINCT 用于返回唯一不同的值。语法：SELECT DISTINCT 列名称 FROM 表名称 SQL WHERE 子句如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。语法:SELECT 列名称 FROM 表名称 WHERE 列 运算符 值下面的运算符可在 WHERE 子句中使用： 操作符 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 != SQL AND &amp; OR 运算符AND 和 OR 运算符用于基于一个以上的条件对记录进行过滤。AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。AND 运算符实例使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人：SELECT * FROM Persons WHERE FirstName=&#39;Thomas&#39; AND LastName=&#39;Carter&#39;OR 运算符实例使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人：SELECT * FROM Persons WHERE firstname=&#39;Thomas&#39; OR lastname=&#39;Carter&#39;结合 AND 和 OR 运算符我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）:SELECT * FROM Persons WHERE (FirstName=&#39;Thomas&#39; OR FirstName=&#39;William&#39;) AND LastName=&#39;Carter&#39; SQL ORDER BY 子句ORDER BY 语句用于对结果集进行排序。ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 实例 1以字母顺序显示公司名称：SELECT Company, OrderNumber FROM Orders ORDER BY Company 实例 2以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber SQL INSERT INTO 语句INSERT INTO 语句用于向表格中插入新的行。语法INSERT INTO 表名称 VALUES (值1, 值2,....)我们也可以指定所要插入数据的列：INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....) 插入新的行“Persons” 表： LastName FirstName Address City Carter Thomas Changan Street Beijing SQL 语句：INSERT INTO Persons VALUES (&#39;Gates&#39;, &#39;Bill&#39;, &#39;Xuanwumen 10&#39;, &#39;Beijing&#39;)结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing 在指定的列中插入数据“Persons” 表： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing SQL 语句：INSERT INTO Persons (LastName, Address) VALUES (&#39;Wilson&#39;, &#39;Champs-Elysees&#39;)结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing Wilson Champs-Elysees Update 语句Update 语句用于修改表中的数据。语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 例子Person: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Champs-Elysees 更新某一行中的一个列我们为 lastname 是 “Wilson” 的人添加 firstname：UPDATE Person SET FirstName = &#39;Fred&#39; WHERE LastName = &#39;Wilson&#39;结果： LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Champs-Elysees 更新某一行中的若干列我们会修改地址（address），并添加城市名称（city）：UPDATE Person SET Address = &#39;Zhongshan 23&#39;, City = &#39;Nanjing&#39; WHERE LastName = &#39;Wilson&#39;结果： LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Zhongshan 23 Nanjing SQL DELETE 语句DELETE 语句用于删除表中的行。语法DELETE FROM 表名称 WHERE 列名称 = 值Person: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Zhongshan 23 Nanjing 删除某行“Fred Wilson” 会被删除：DELETE FROM Person WHERE LastName = &#39;Wilson&#39;结果: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing 删除所有行可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：DELETE FROM table_name或者：DELETE * FROM table_name","categories":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/categories/SQL/"}],"tags":[{"name":"-SQL -技术 -基础","slug":"SQL-技术-基础","permalink":"http://yoursite.com/tags/SQL-技术-基础/"}]},{"title":"奇淫巧技","slug":"奇淫巧技","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-23T00:33:59.713Z","comments":true,"path":"2019/10/16/奇淫巧技/","link":"","permalink":"http://yoursite.com/2019/10/16/奇淫巧技/","excerpt":"","text":"Dos代码雨@echo off color 0a :start set num=0 set \"echos= \" :num set /a a1=%random%%%3 if \"%a1%\" == \"1\" set \"a1= \" if \"%a1%\" == \"2\" set \"a1= \" if \"%a1%\" == \"0\" set /a a1=%random%%%2 set echos=%echos%%a1% set /a num=%num%+1 if \"%num%\" == \"75\" echo %echos%&&goto :start goto :num MySQL查看表的所有列show full columns from [table] JavaScript删除数组var arr = [1,2,3,4]; console.log(arr); arr.length = 0; console.log(arr); 特别简单的取整技巧var num = 5.6664; console.log(~~num);//5","categories":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/categories/技巧/"}],"tags":[{"name":"-Dos -技术 -巧记","slug":"Dos-技术-巧记","permalink":"http://yoursite.com/tags/Dos-技术-巧记/"}]},{"title":"Java总结","slug":"Java总结","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-17T09:37:33.419Z","comments":true,"path":"2019/10/16/Java总结/","link":"","permalink":"http://yoursite.com/2019/10/16/Java总结/","excerpt":"","text":"Java开篇javaSE（标准版） javaEE（企业版） javaME（微型版） JDK（java开发工具包）JRE（java运行环境）IDE（集成开发环境） Java SE（Java Platform，Standard Edition）。Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。 J2SE就是做那种桌面安装程序样的，像QQ，WORD那种应用程序。Java EE（Java Platform，Enterprise Edition）。这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。 J2EE 就是做基于Internet的应用程序，像选课系统，企业网站，银行系统之类的。Java ME（Java Platform，Micro Edition）。这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。 J2ME就是做嵌入式系统开发的，像手机游戏之类的，像现在流行的Android操作系统。JDK（Java Development Kit）。JRE（Java Runtime Environment）IDE（Ind Depvelopment Environment） ##一、面向对象 类、对象、变量（1）所有的Java程序都已类class为组织单元；类由属性和方法两部分组成（2）先创建对象，再使用对象（3）成员变量：类中定义，自动定义初始值局部变量：类方法中定义（两变量同名，局部变量有更高的优先级） 构造方法构造方法是定义在java类中的一个用来初始化对象的方法，与类同名且没有返回值。 public 构造方法名（）{ } 其中构造方法名与类同名；当没有指定的构造方法时，系统会自动添加无参构造方法 Static使用Static修饰的成员属于整个类，被类的所有对象共享。可通过使用类名直接访问静态成员，也可通过对象名Static可以修饰变量、方法和代码块 （1）Static使用之静态方法public class Helloworld { public static void print() { System.out.println(“***”); } public static void main(String[] args) { Helloworld.print(); Helloworld demo = new Helloworld; demo.print(); } } 注意：静态方法中可以直接调用同类的静态成员，但不可以直接调用非静态成员；普通成员方法中可以直接访问同类的非静态变量和静态变量；静态方法中不能直接调用非静态成员方法 （2）Static使用之静态初始化块静态初始化块在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通成员 public class Helloworld { int num1; int num2; static int num3; public Helloworld() { num1 = 91; System.out.println(\"构造方法为num1赋值\"); num2 = 74; System.out.println(\"初始化块为num2赋值\"); num3 = 83; System.out.println(\"静态初始化块为num3赋值\"); } public static void main(String[] args) { Helloworld hello = new Helloworld(); System.out.println(hello.num1); System.out.println(hello.num2); System.out.println(num3); Helloworld hello2 = new Helloworld(); } } 运行结果：静态初始化块为num3赋值初始化块为num2赋值构造方法为num1赋值 91 74 83 初始化块为num2赋值构造方法为num1赋值 二、java面向对象的特性封装性：将类的某些信息隐藏在内部，通过类的方法来实现操作访问步骤：1 修改属性可见性；2 创建getter\\setter方法；3在方法中加入属性控制语句 (1)静态内部类:public class SOuter { private int a = 99; static int b = 1; public static class SInner { int b = 2; public void test() { System.out.println(\"访问外部类b\" + SOuter.b); System.out.println(\"访问内部类b\" + b); } } public static void main(String[] args) { //三行表示 SInner sInner; sInner = new SInner(); sInner.test(); //两行表示 SInner si = new SInner(); si.test(); //一行表示 new SInner().test(); } } (2)成员内部类：访问外部类时使用this指针（3）方法内部类：只能在该方法中使用，且不能使用访问控制符和Static修饰符 2. 继承性（1）一般形式：class 子类 extends 父类（2）方法重写：子类对继承的父类方法不满意可以重写，调用时优先调用子类方法（3）继承的初始化顺序：先初始化父类，再到子类；先执行初始化对象中属性，再执行狗在方法中的初始化（4）父类对象–属性初始化–构造方法–子类对象–属性初始化–构造方法（5）注意：如果子类构造方法中没有显示调用父类的构造方法，默认调用父类无参构造方法，若此父类没用无参的构造方法，则编译出错 多态性引用多态：父类的引用可以指向本类的对象，也可指向子类的对象方法多态：创建本类对象时，调用的方法为本类方法；创建子类对象时，调用的方法为子类的重写的方法或者继承的方法 （1）抽象类用关键字abstract修饰：抽象类只用声明不需要实现；包含抽象方法的类为抽象类；抽象类不能直接创建，可以定义引用变量。 public abstract class Telphone{ public abstract void call(); //抽象方法没有方法体，以分号结束 } （2）接口（一种特殊的类，有全局变量和公共抽象方法组成）[修饰符] class 类名 extends 父类implemrnts 接口1,2…… {类体部分 } 注：接口经常与匿名内部类配合使用 public interface Iplay{ public void phone(); } public class People implements Iplay{ public static void main(String[] args){ People test=new People(); test.phone(); } public void phone(){ System.out.println(“手机可以玩游戏”); } } 1.String、StringBuilder、StringBuffer的区别是什么，String为什么是不可变的？不可变性String类的底层源码中，通过final关键字修饰字符串数组，private final char value[]，所以是不可变的。StringBuffer和StringBuilder类是集成自 AbstractStringBuilder 类， AbstractStringBuilder 类中的变量没有用final关键字修饰，所以是可变的。 线程安全性String是不可变的，是常量，所以是线程安全的。StringBuilder和StringBuffer都继承自AbstractStringBuilder 类，StringBuffer对方法加了同步锁，所以是线程安全的，而StringBuilder没有加同步锁，所以是线程不安全的。 性能对String类型进行改变是都会new一个新的string对象，并指向新的对象； StringBuffer直接通过改变自身变量的值，StringBuilder相对能提升性能，但有线程不安全的情况。 2.== 与 equals==用来判断两个对象是否相等，基础数据类型比较的是值是否相等。 没有重写对象的equals方法时，也是用来比较两个对象是否相等，重写equals方法可以比较内容相等，返回true 3.try/catch/finally中finally是否一定执行在以下4种特殊情况下，finally块不会被执行: 在finally语句块中发生了异常。 在前面的代码中用了System.exit()退出程序。 程序所在的线程死亡。 关闭CPU。 4.接口和抽象类的区别？1.抽象类中可以实现方法，抽象接口不能实现方法（jdk1.8以后可以实现方法）； 2.接口中的变量默认是final类型，而抽象类不是； 3.类只能继承一个抽象类，而接口可以实现多个； 4.类继承接口需要实现所有方法，抽象类不需要； 5.接口不能用new实例化，可以声明。必须引用一个实现该接口的对象抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。5.Arraylist 与 LinkedList 异同安全性ArrayList与LinkedList都是线程不安全的。 数据结构实现ArryayList是基于Object数组，而LinkedList是基于双向循环链表（JDK1.6之前为循环链表，之后取消了循环） 插入删除的影响ArrayList采用数组存储，插入删除受元素位置的影响； LinkedList采用链表存储，插入删除不收元素位置影响； 访问元素LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,未实现RandomAccess接口的list， 优先选择iterator遍历(foreach遍历底层也是通过iterator实现的)，大size的数据，千万不要使用普通for循环 6.ArrayList 与 Vector 区别Vector中所有方法都是同步的，在多线程操作中，同步操作会耗费时间，而ArrayList是不需要同步的，在不需要考虑线程安全时可以使用。 7.HashMap的底层实现待补充完善 8.HashSet 和 HashMap 区别HashMap实现Map接口，用来存储键值对，调用put方法添加元素，使用Key计算Hashcode，而HashSet实现Set接口，用来存储对象，调用add方法添加对象，使用对象计算hashcode，根据equals方法判断对象相等，执行效率的话，HashMap优与HashSet。 9.ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。ConcurrentHashMap使用的是分段锁，HashTable使用的是同一把锁，因而在多线程并发中效率很低。 10.多线程实现方式1.继承Thread类，2.实现Runnable接口，3.基于线程池实现","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"-java -技术 -总结","slug":"java-技术-总结","permalink":"http://yoursite.com/tags/java-技术-总结/"}]},{"title":"Hexo安装教程","slug":"Hexo","date":"2019-10-16T08:38:53.000Z","updated":"2019-12-04T11:22:20.577Z","comments":true,"path":"2019/10/16/Hexo/","link":"","permalink":"http://yoursite.com/2019/10/16/Hexo/","excerpt":"","text":"安装hexo基础框架npm install hexo-cli -g更新内容我是用windows系统，打开cmd然后进入到你的博客文件目录，输入以下命令 hexo clean hexo g hexo d网易云音乐外链https://music.163.com/song/media/outer/url?id=484365611.mp3清空git缓存git rm -r --cached . git gc更换仓库：git remote -v git remote set-url origin 新仓库 git remote set-url origin https://github.com/xiu0928/love.git查看当前用户名和邮箱git config user.name git config user.email修改git config --global user.name &quot;xiu0928&quot; git config --global user.email &quot;2011447576@qq.com&quot;上传项目git init git add . git commit -m &quot;first commit&quot; git remote add origin https://自己的仓库url地址（上面有说到） 将本地的仓库关联到github上， git push -u origin master更新到GitHub上hexo clean hexo generate hexo deploy更新到GitHub上git clone https://github.com/xiu0928/xiu0928.github.io .deploy/xiu0928.github.io hexo generate cp -R public/* .deploy/xiu0928.github.io cd .deploy/xiu0928.github.io git add . git commit -m &quot;update&quot; git push","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"-Hexo -技术 -Git","slug":"Hexo-技术-Git","permalink":"http://yoursite.com/tags/Hexo-技术-Git/"}]}]}