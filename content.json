{"meta":{"title":"我的快乐","subtitle":"欢迎光临 我的快乐","description":null,"author":"李秀远","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-10-14T05:10:38.000Z","updated":"2019-10-15T06:55:43.792Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2019-10-15T06:56:52.162Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-10-15T06:57:48.160Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2019-10-15T06:57:25.457Z","comments":true,"path":"contact/index.html","permalink":"http://yoursite.com/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-14T05:11:36.000Z","updated":"2019-10-15T06:56:10.881Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL语法","slug":"SQL语法","date":"2019-10-22T02:54:39.000Z","updated":"2019-10-22T09:45:40.001Z","comments":true,"path":"2019/10/22/SQL语法/","link":"","permalink":"http://yoursite.com/2019/10/22/SQL语法/","excerpt":"","text":"1.数据库基础语法创建数据库create database 数据库名; 删除数据库drop database 数据库名; 选择数据库use 数据库名; 2.表的约束主键约束primary key 主键自增auto_increment primary key 外键约束命名写法：constraint 外键约束的名称foreign key(teaid)//将从表中的teaid设为外键references student(teaid);关联student表的teaid主键增加外键约束alter table 表名add constraint 外键约束的名称foreign key(teaid)//将从表中的teaid设为外键references student(teaid);关联student表的teaid主键不命名写法：alter table 表名 add foreign key(外键) references 从表(外键); 非空约束not null 默认约束default 默认值 唯一约束unique 3.操作表的结构创建表create table 表名(字段名1 类型1 约束,...); 修改表名rename table 旧表名 to 新表名 修改表结构alter table 表名 动作 动作修改字段类型：modify 字段名 新类型修改字段名：change 老字段名 新字段名 新字段类型添加字段:add 字段名 字段类型删除字段:drop 字段名 删除表dorp table 表名 查看表结构desc 表名; 4.操作表的数据插入数据insert into 表名(字段一,...) values(值一,...); 更新语句update 表名 set 字段一 = 值一,... where 条件 删除语句delete from 表名 where 条件注意：先删除从表记录，再删除主表记录 清空语句delete from 表名truncate table 表名区别：truncate将重置auto_increment不可恢复数据 查询语句select 字段名 聚合函数from 表名where 条件order by 字段名 asc/desclimit 字段名 限制行数group by 字段名having 条件 //主要解决条件语句不能用聚合函数问题 常用模糊查询where 字段名 like &#39;值&#39; * 任意字符串 % 表示任意长度的字符，0也是任意长度 _ 表示只有一个字符 常用聚合函数 sum（字段名） 求和 max（字段名） 最大数 min（字段名） 最小值 avg（字段名） 平均数 count（字段名） 个数 count（字段名）和count（*）区别就是：count（字段名）如果字段有null值，则不计数 多表查询内连接select 字段一，字段二，...from 表一 inner join 表二 on 条件; 左连接select 字段一，字段二，...from 表一 left join 表二 on 条件； 右连接select 字段一，字段二，...from 表一 right join 表二 on 条件；","categories":[],"tags":[{"name":"-语法 -SQL","slug":"语法-SQL","permalink":"http://yoursite.com/tags/语法-SQL/"}]},{"title":"ArrayList总结","slug":"ArrayList总结","date":"2019-10-19T12:45:18.000Z","updated":"2019-10-19T13:06:03.544Z","comments":true,"path":"2019/10/19/ArrayList总结/","link":"","permalink":"http://yoursite.com/2019/10/19/ArrayList总结/","excerpt":"","text":"ArrayList1.底层是利用（动态）数组形式实现 1.52.如何构建一个ArrayList对象无参构造方法 带默认容量的构造方法List&lt;String&gt; list=new ArrayList&lt;String&gt;(); 3.常用方法增 add（E e）删 remove（index）改 set（index value）查 get（index）长度 size（） 泛型：用来规定数据类型注意：泛型 造型在类或接口描述的时候 可以使用某种符号来表示一个未知的类型在类型使用的时候 需要一个具体类型来代替注意：泛型需要使用应用数据类型来代替1.泛型类 2.泛型接口 3.泛型方法 4.方法参数泛型限制 Vector类1.是ArrayList集合早期版本线程同步 安全性高 效率 2.扩容方式不同2倍 可通过构造方法创建对象时修改这一机制","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"-泛型 -Vector -ArrayList","slug":"泛型-Vector-ArrayList","permalink":"http://yoursite.com/tags/泛型-Vector-ArrayList/"}]},{"title":"Set总结","slug":"Set总结","date":"2019-10-19T12:45:02.000Z","updated":"2019-10-19T13:46:15.559Z","comments":true,"path":"2019/10/19/Set总结/","link":"","permalink":"http://yoursite.com/2019/10/19/Set总结/","excerpt":"","text":"SetCollection 以value形式存在Set 无序无重复 1.具体实现类HashSetTreeSet 2.基本的使用3.无序 无重复无序：我们使用集合存放的顺序 集合内取出来的顺序不一致集合本身是有自己的算法排布顺序 hash算法 HashSet—&gt;（HashMap 数组+链表 散链表）1.java.utill2.如何创建对象 无参数 有参数HashSet&lt;String&gt; set =new HashSet&lt;String&gt;(); 3.集合容器的基本使用 增 add(value) addAall(collection c) retainAll removeAll 并集 交集 差集 删 boolean = remove(Objest) 改 没有 查 增强for循环集合遍历 12345678910for(String v:set)&#123;System.out.println(v);&#125;//迭代器：Iterator&lt;String&gt; it = set.iterator();//判断下一个位置是否有元素while(it.hasNext())&#123; String value = it.next(); System.out.println(value);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"-Set","slug":"Set","permalink":"http://yoursite.com/tags/Set/"}]},{"title":"Map总结","slug":"Map总结","date":"2019-10-19T12:44:45.000Z","updated":"2019-10-19T13:31:14.176Z","comments":true,"path":"2019/10/19/Map总结/","link":"","permalink":"http://yoursite.com/2019/10/19/Map总结/","excerpt":"","text":"https://docs.oracle.com/javase/8/docs/api/ Map映射 通过某一个key可以直接定位到value值存储的方式：键值对 存储 key-valuekey无序无重复 value无序可重复 map基本使用：HashMapHashSetHashtable##HashMap: 1.包 java.util2.如何创建对象HashMap&lt;Integer,String&gt; hashmap = new HashMap&lt;Integer,String&gt;(); 3.基本方法 增 put（key,value）存储一组映射关系 key-value 删 E = remove（key; 改 replace(key,new value); 查 get(key); 遍历 //获取map集合的全部key 12345678Set&lt;Integer&gt; keys = map.keySet();//通过迭代器去遍历keysIterator&lt;Integer&gt; it = keys.iterator();while(it.hasNext())&#123; Integer key = it.next(); String value = map.get(key); System.out.println(key+\"-\"+value);&#125; size(); 4.除了上面的几个常用的方法可以去api去看5.map集合什么情况下用：1.想要存储一组元素数组 or 集合 如果存储的元素以后长度不变用数组，不确定用集合 2.如果发现长度以后不确定 –&gt;集合 List Set Map 有序 无重复 k-v ArrayList适合遍历 Hash性能高 Hash性能高 LinkedList适合插入删除 Tree希望自动去重和排序 Tree希望key自动排序 StackLIFO","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"-Map","slug":"Map","permalink":"http://yoursite.com/tags/Map/"}]},{"title":"SQL 函数","slug":"SQL函数","date":"2019-10-17T09:36:12.000Z","updated":"2019-10-17T10:59:01.561Z","comments":true,"path":"2019/10/17/SQL函数/","link":"","permalink":"http://yoursite.com/2019/10/17/SQL函数/","excerpt":"","text":"avg（）函数定义和用法AVG 函数返回数值列的平均值。NULL 值不包括在计算中。 SQL AVG() 语法select avg(字段名)as 新字段名 from 表名; 实例我们拥有下面这个stuinfo表： id date name age ach tuition sex 1 2019-10-17 17:44:45 亚索 18 84 10600 男 2 2018-10-17 17:45:42 寒冰 16 95 10600 女 3 2019-08-01 17:45:34 布隆 10 84 10000 男 4 2019-01-17 17:46:42 劫 23 99 500 男 5 2019-10-13 17:46:52 小鱼儿 45 84 6000 女 例子 1现在，我们希望计算 age 字段的平均值。 我们使用如下 SQL 语句：select avg(age)as avgAge from stuinfo;结果集类似这样： avgAge 22.4000 例子 2现在，我们希望找到 age 值高于 age 平均值的客户。我们使用如下 SQL 语句：select name from stuinfo where age&gt;(select avg(age) from stuinfo); name 劫 小鱼儿 count()语句COUNT() 函数返回匹配指定条件的行数。 COUNT(column_name)函数返回指定列的值的数目（NULL 不计入）：语法SELECT COUNT(column_name) FROM table_name COUNT(*)函数返回表中的记录数：SELECT COUNT(*) FROM table_name COUNT(DISTINCT column_name)函数返回指定列的不同值的数目：SELECT COUNT(DISTINCT column_name) FROM table_name 实例我们拥有下面这个stuinfo表： id date name age ach tuition sex 1 2019-10-17 17:44:45 亚索 18 84 10600 男 2 2018-10-17 17:45:42 寒冰 16 95 10600 女 3 2019-08-01 17:45:34 布隆 10 84 10000 男 4 2019-01-17 17:46:42 劫 23 99 500 男 5 2019-10-13 17:46:52 小鱼儿 45 84 6000 女 现在，我们希望计算学生 tuition 的10600学费总数。我们使用如下 SQL 语句：select count(tuition) as countTuition from stuinfo where tuition = 10600;以上 SQL 语句的结果是 2，因为学生 tuition 共有 2 人： countTuition 2 SQL COUNT(*) 实例如果我们省略 WHERE 子句，比如这样：select count(*) as count from stuinfo;结果集类似这样： count 5 这是表中的总行数。 SQL COUNT(DISTINCT column_name) 实例现在，我们希望计算 “stuinfo” 表中不同成绩的数目。我们使用如下 SQL 语句：select count(distinct ach) as numAch from stuinfo;结果集类似这样： numAch 3 max()函数MAX 函数返回一列中的最大值。NULL 值不包括在计算中。SQL MAX() 语法SELECT MAX(column_name) FROM table_name min()函数MIN 函数返回一列中的最小值。NULL 值不包括在计算中。SQL MIN() 语法SELECT MIN(column_name) FROM table_name注释：MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。 sum()函数SUM 函数返回数值列的总数（总额）。SQL SUM() 语法SELECT SUM(column_name) FROM table_name first()函数FIRST() 函数返回指定的字段中第一个记录的值。 提示：可使用 ORDER BY 语句对记录进行排序。SQL FIRST() 语法SELECT FIRST(column_name) FROM table_name list()函数LAST() 函数返回指定的字段中最后一个记录的值。 提示：可使用 ORDER BY 语句对记录进行排序。SQL LAST() 语法SELECT LAST(column_name) FROM table_name Group By函数GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。SQL GROUP BY 语法 1234SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name 实例我们拥有下面这个 “stuinfo” 表： id date name age ach tuition sex 1 2019-10-17 17:44:45 亚索 18 84 10600 男 2 2018-10-17 17:45:42 寒冰 16 95 10600 女 3 2019-08-01 17:45:34 布隆 10 84 10000 男 4 2019-01-17 17:46:42 劫 23 99 500 男 5 2019-10-13 17:46:52 小鱼儿 45 84 6000 女 现在我们希望查找男生和女生的总分数并想要使用 GROUP BY 进行组合。我们使用下列 SQL 语句：select sex,sum(ach) from stuinfo group by sex;结果： sex sum(ach) 女 179 男 267 Having();在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。SQL HAVING 语法 12345SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_nameHAVING aggregate_function(column_name) operator value","categories":[{"name":"SQL函数","slug":"SQL函数","permalink":"http://yoursite.com/categories/SQL函数/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"Hexo安装教程","slug":"Hexo","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-18T02:55:45.569Z","comments":true,"path":"2019/10/16/Hexo/","link":"","permalink":"http://yoursite.com/2019/10/16/Hexo/","excerpt":"","text":"安装hexo基础框架1npm install hexo-cli -g 更新内容我是用windows系统，打开cmd然后进入到你的博客文件目录，输入以下命令 123hexo cleanhexo ghexo d 网易云音乐外链1https://music.163.com/song/media/outer/url?id=484365611.mp3 清空git缓存12git rm -r --cached .git gc 更换仓库：1234git remote -vgit remote set-url origin 新仓库git remote set-url origin https://github.com/xiu0928/love.git 查看当前用户名和邮箱12git config user.namegit config user.email 修改12git config --global user.name &quot;xiu0928&quot;git config --global user.email &quot;2011447576@qq.com&quot; 上传项目123456789git initgit add . git commit -m &quot;first commit&quot;git remote add origin https://自己的仓库url地址（上面有说到） 将本地的仓库关联到github上，git push -u origin master 更新到GitHub上12345hexo cleanhexo generatehexo deploy 更新到GitHub上12345678910111213git clone https://github.com/xiu0928/xiu0928.github.io .deploy/xiu0928.github.iohexo generate //生成静态文件cp -R public/* .deploy/xiu0928.github.io //复制文件cd .deploy/xiu0928.github.io //切换目录git add . //将需要提交的代码添加到暂存区git commit -m &quot;update&quot; //将暂存区内容提交给本地版本库git push //推送给远程服务器","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"-Hexo -技术 -Git","slug":"Hexo-技术-Git","permalink":"http://yoursite.com/tags/Hexo-技术-Git/"}]},{"title":"奇淫巧技","slug":"奇淫巧技","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-17T09:37:44.417Z","comments":true,"path":"2019/10/16/奇淫巧技/","link":"","permalink":"http://yoursite.com/2019/10/16/奇淫巧技/","excerpt":"","text":"Dos代码雨1234567891011121314@echo offcolor 0a:startset num=0set \"echos= \":numset /a a1=%random%%%3if \"%a1%\" == \"1\" set \"a1= \"if \"%a1%\" == \"2\" set \"a1= \"if \"%a1%\" == \"0\" set /a a1=%random%%%2set echos=%echos%%a1%set /a num=%num%+1if \"%num%\" == \"75\" echo %echos%&amp;&amp;goto :startgoto :num MySQL查看表的所有列show full columns from [table] JavaScript删除数组1234567var arr = [1,2,3,4];console.log(arr);arr.length = 0;console.log(arr); 特别简单的取整技巧12var num = 5.6664;console.log(~~num);//5","categories":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/categories/技巧/"}],"tags":[{"name":"-Dos -技术 -巧记","slug":"Dos-技术-巧记","permalink":"http://yoursite.com/tags/Dos-技术-巧记/"}]},{"title":"SQL基础","slug":"SQL总结","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-17T09:37:49.197Z","comments":true,"path":"2019/10/16/SQL总结/","link":"","permalink":"http://yoursite.com/2019/10/16/SQL总结/","excerpt":"","text":"SQL 语法数据库表一个数据库通常包含一个或多个表。每个表由一个名字标识（例如“客户”或者“订单”）。表包含带有数据的记录（行） SQL 语句您需要在数据库上执行的大部分工作都由 SQL 语句完成。下面的语句从表中选取 LastName 列的数据：SELECT LastName FROM Persons重要事项：SQL 对大小写不敏感！ SQL DML 和 DDL可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。 查询和更新指令构成了 SQL 的 DML 部分： SELECT - 从数据库表中获取数据 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。SQL 中最重要的 DDL 语句: CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL SELECT 语句SELECT 语句用于从表中选取数据。 结果被存储在一个结果表中（称为结果集）。 SQL SELECT 语法SELECT 列名称 FROM 表名称以及：SELECT * FROM 表名称 SQL SELECT DISTINCT 语句在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。 关键词 DISTINCT 用于返回唯一不同的值。语法：SELECT DISTINCT 列名称 FROM 表名称 SQL WHERE 子句如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。语法:SELECT 列名称 FROM 表名称 WHERE 列 运算符 值下面的运算符可在 WHERE 子句中使用： 操作符 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 != SQL AND &amp; OR 运算符AND 和 OR 运算符用于基于一个以上的条件对记录进行过滤。AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。AND 运算符实例使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人：SELECT * FROM Persons WHERE FirstName=&#39;Thomas&#39; AND LastName=&#39;Carter&#39;OR 运算符实例使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人：SELECT * FROM Persons WHERE firstname=&#39;Thomas&#39; OR lastname=&#39;Carter&#39;结合 AND 和 OR 运算符我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）:SELECT * FROM Persons WHERE (FirstName=&#39;Thomas&#39; OR FirstName=&#39;William&#39;) AND LastName=&#39;Carter&#39; SQL ORDER BY 子句ORDER BY 语句用于对结果集进行排序。ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 实例 1以字母顺序显示公司名称：SELECT Company, OrderNumber FROM Orders ORDER BY Company 实例 2以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber SQL INSERT INTO 语句INSERT INTO 语句用于向表格中插入新的行。语法INSERT INTO 表名称 VALUES (值1, 值2,....)我们也可以指定所要插入数据的列：INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....) 插入新的行“Persons” 表： LastName FirstName Address City Carter Thomas Changan Street Beijing SQL 语句：INSERT INTO Persons VALUES (&#39;Gates&#39;, &#39;Bill&#39;, &#39;Xuanwumen 10&#39;, &#39;Beijing&#39;)结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing 在指定的列中插入数据“Persons” 表： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing SQL 语句：INSERT INTO Persons (LastName, Address) VALUES (&#39;Wilson&#39;, &#39;Champs-Elysees&#39;)结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing Wilson Champs-Elysees Update 语句Update 语句用于修改表中的数据。语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 例子Person: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Champs-Elysees 更新某一行中的一个列我们为 lastname 是 “Wilson” 的人添加 firstname：UPDATE Person SET FirstName = &#39;Fred&#39; WHERE LastName = &#39;Wilson&#39;结果： LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Champs-Elysees 更新某一行中的若干列我们会修改地址（address），并添加城市名称（city）：UPDATE Person SET Address = &#39;Zhongshan 23&#39;, City = &#39;Nanjing&#39; WHERE LastName = &#39;Wilson&#39;结果： LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Zhongshan 23 Nanjing SQL DELETE 语句DELETE 语句用于删除表中的行。语法DELETE FROM 表名称 WHERE 列名称 = 值Person: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Zhongshan 23 Nanjing 删除某行“Fred Wilson” 会被删除：DELETE FROM Person WHERE LastName = &#39;Wilson&#39;结果: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing 删除所有行可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：DELETE FROM table_name或者：DELETE * FROM table_name","categories":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/categories/SQL/"}],"tags":[{"name":"-SQL -技术 -基础","slug":"SQL-技术-基础","permalink":"http://yoursite.com/tags/SQL-技术-基础/"}]},{"title":"Java总结","slug":"Java总结","date":"2019-10-16T08:38:53.000Z","updated":"2019-10-17T09:37:33.419Z","comments":true,"path":"2019/10/16/Java总结/","link":"","permalink":"http://yoursite.com/2019/10/16/Java总结/","excerpt":"","text":"Java开篇javaSE（标准版） javaEE（企业版） javaME（微型版） JDK（java开发工具包）JRE（java运行环境）IDE（集成开发环境） Java SE（Java Platform，Standard Edition）。Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。 J2SE就是做那种桌面安装程序样的，像QQ，WORD那种应用程序。Java EE（Java Platform，Enterprise Edition）。这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。 J2EE 就是做基于Internet的应用程序，像选课系统，企业网站，银行系统之类的。Java ME（Java Platform，Micro Edition）。这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。 J2ME就是做嵌入式系统开发的，像手机游戏之类的，像现在流行的Android操作系统。JDK（Java Development Kit）。JRE（Java Runtime Environment）IDE（Ind Depvelopment Environment） ##一、面向对象 类、对象、变量（1）所有的Java程序都已类class为组织单元；类由属性和方法两部分组成（2）先创建对象，再使用对象（3）成员变量：类中定义，自动定义初始值局部变量：类方法中定义（两变量同名，局部变量有更高的优先级） 构造方法构造方法是定义在java类中的一个用来初始化对象的方法，与类同名且没有返回值。 123public 构造方法名（）&#123;&#125; 其中构造方法名与类同名；当没有指定的构造方法时，系统会自动添加无参构造方法 Static使用Static修饰的成员属于整个类，被类的所有对象共享。可通过使用类名直接访问静态成员，也可通过对象名Static可以修饰变量、方法和代码块 （1）Static使用之静态方法123456789101112public class Helloworld &#123;public static void print() &#123;System.out.println(“***”);&#125;public static void main(String[] args) &#123; Helloworld.print(); Helloworld demo = new Helloworld; demo.print();&#125;&#125; 注意：静态方法中可以直接调用同类的静态成员，但不可以直接调用非静态成员；普通成员方法中可以直接访问同类的非静态变量和静态变量；静态方法中不能直接调用非静态成员方法 （2）Static使用之静态初始化块静态初始化块在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通成员 1234567891011121314151617181920212223public class Helloworld &#123;int num1;int num2;static int num3;public Helloworld() &#123; num1 = 91; System.out.println(\"构造方法为num1赋值\"); num2 = 74; System.out.println(\"初始化块为num2赋值\"); num3 = 83; System.out.println(\"静态初始化块为num3赋值\");&#125;public static void main(String[] args) &#123; Helloworld hello = new Helloworld(); System.out.println(hello.num1); System.out.println(hello.num2); System.out.println(num3); Helloworld hello2 = new Helloworld();&#125;&#125; 运行结果：静态初始化块为num3赋值初始化块为num2赋值构造方法为num1赋值 123917483 初始化块为num2赋值构造方法为num1赋值 二、java面向对象的特性封装性：将类的某些信息隐藏在内部，通过类的方法来实现操作访问步骤：1 修改属性可见性；2 创建getter\\setter方法；3在方法中加入属性控制语句 (1)静态内部类:123456789101112131415161718192021222324252627282930public class SOuter &#123;private int a = 99;static int b = 1;public static class SInner &#123; int b = 2; public void test() &#123; System.out.println(\"访问外部类b\" + SOuter.b); System.out.println(\"访问内部类b\" + b); &#125;&#125;public static void main(String[] args) &#123; //三行表示 SInner sInner; sInner = new SInner(); sInner.test(); //两行表示 SInner si = new SInner(); si.test(); //一行表示 new SInner().test();&#125;&#125; (2)成员内部类：访问外部类时使用this指针（3）方法内部类：只能在该方法中使用，且不能使用访问控制符和Static修饰符 2. 继承性（1）一般形式：class 子类 extends 父类（2）方法重写：子类对继承的父类方法不满意可以重写，调用时优先调用子类方法（3）继承的初始化顺序：先初始化父类，再到子类；先执行初始化对象中属性，再执行狗在方法中的初始化（4）父类对象–属性初始化–构造方法–子类对象–属性初始化–构造方法（5）注意：如果子类构造方法中没有显示调用父类的构造方法，默认调用父类无参构造方法，若此父类没用无参的构造方法，则编译出错 多态性引用多态：父类的引用可以指向本类的对象，也可指向子类的对象方法多态：创建本类对象时，调用的方法为本类方法；创建子类对象时，调用的方法为子类的重写的方法或者继承的方法 （1）抽象类用关键字abstract修饰：抽象类只用声明不需要实现；包含抽象方法的类为抽象类；抽象类不能直接创建，可以定义引用变量。 123public abstract class Telphone&#123;public abstract void call(); //抽象方法没有方法体，以分号结束&#125; （2）接口（一种特殊的类，有全局变量和公共抽象方法组成）123[修饰符] class 类名 extends 父类implemrnts 接口1,2……&#123;类体部分&#125; 注：接口经常与匿名内部类配合使用 123456789101112public interface Iplay&#123;public void phone();&#125;public class People implements Iplay&#123;public static void main(String[] args)&#123;People test=new People();test.phone();&#125;public void phone()&#123;System.out.println(“手机可以玩游戏”);&#125;&#125; 1.String、StringBuilder、StringBuffer的区别是什么，String为什么是不可变的？不可变性String类的底层源码中，通过final关键字修饰字符串数组，private final char value[]，所以是不可变的。StringBuffer和StringBuilder类是集成自 AbstractStringBuilder 类， AbstractStringBuilder 类中的变量没有用final关键字修饰，所以是可变的。 线程安全性String是不可变的，是常量，所以是线程安全的。StringBuilder和StringBuffer都继承自AbstractStringBuilder 类，StringBuffer对方法加了同步锁，所以是线程安全的，而StringBuilder没有加同步锁，所以是线程不安全的。 性能对String类型进行改变是都会new一个新的string对象，并指向新的对象； StringBuffer直接通过改变自身变量的值，StringBuilder相对能提升性能，但有线程不安全的情况。 2.== 与 equals==用来判断两个对象是否相等，基础数据类型比较的是值是否相等。 没有重写对象的equals方法时，也是用来比较两个对象是否相等，重写equals方法可以比较内容相等，返回true 3.try/catch/finally中finally是否一定执行在以下4种特殊情况下，finally块不会被执行: 在finally语句块中发生了异常。 在前面的代码中用了System.exit()退出程序。 程序所在的线程死亡。 关闭CPU。 4.接口和抽象类的区别？1.抽象类中可以实现方法，抽象接口不能实现方法（jdk1.8以后可以实现方法）； 2.接口中的变量默认是final类型，而抽象类不是； 3.类只能继承一个抽象类，而接口可以实现多个； 4.类继承接口需要实现所有方法，抽象类不需要； 5.接口不能用new实例化，可以声明。必须引用一个实现该接口的对象抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。5.Arraylist 与 LinkedList 异同安全性ArrayList与LinkedList都是线程不安全的。 数据结构实现ArryayList是基于Object数组，而LinkedList是基于双向循环链表（JDK1.6之前为循环链表，之后取消了循环） 插入删除的影响ArrayList采用数组存储，插入删除受元素位置的影响； LinkedList采用链表存储，插入删除不收元素位置影响； 访问元素LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,未实现RandomAccess接口的list， 优先选择iterator遍历(foreach遍历底层也是通过iterator实现的)，大size的数据，千万不要使用普通for循环 6.ArrayList 与 Vector 区别Vector中所有方法都是同步的，在多线程操作中，同步操作会耗费时间，而ArrayList是不需要同步的，在不需要考虑线程安全时可以使用。 7.HashMap的底层实现待补充完善 8.HashSet 和 HashMap 区别HashMap实现Map接口，用来存储键值对，调用put方法添加元素，使用Key计算Hashcode，而HashSet实现Set接口，用来存储对象，调用add方法添加对象，使用对象计算hashcode，根据equals方法判断对象相等，执行效率的话，HashMap优与HashSet。 9.ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。ConcurrentHashMap使用的是分段锁，HashTable使用的是同一把锁，因而在多线程并发中效率很低。 10.多线程实现方式1.继承Thread类，2.实现Runnable接口，3.基于线程池实现","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"-java -技术 -总结","slug":"java-技术-总结","permalink":"http://yoursite.com/tags/java-技术-总结/"}]}]}